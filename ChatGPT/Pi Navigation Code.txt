Weiter zum Inhalt
Chatverlauf

Du:
ich will ein Navigationsgerät basteln mit Arduino und einem Raspberry Pi, auf dem Valhalla läuft. Aktuell gibt das Navigationsgerät schriftliche Anweisungen aus, ich habe jedoch auch Piktogramme gemacht für links/rechts abbiegen/einspuren, geradeaus fahren und für einen Kreisverkehr mit bis zu 9 Ausfahrten. Ich möchte eine Fusion aus Text und Bild, also ein Piktogramm und dann vielleicht einen Strassennamen und eine Distanz. Bisher habe ich folgendes:
Raspberry Pi Code:
# >>> ZIEL & MAUT (nur diese 3 Zeilen bei Bedarf ändern) <<<
DST_LAT = 47.1662         # Ziel-Breitengrad
DST_LON = 8.5160          # Ziel-Längengrad
EXCLUDE_TOLLS = True      # True = Maut vermeiden, False = Maut erlaubt

# ===== ab hier nichts mehr ändern, außer Port/Baud falls nötig =====
import json, subprocess, time, threading, os, sys
import RPi.GPIO as GPIO
import serial

# Hardware/Timing
BTN_PIN = 26                     # BCM 26 (physischer Pin 37), Taster gegen GND → Start Navigation
BTN_GPSD = 19                    # BCM 19 (physischer Pin 35), Taster gegen GND → gpsd restart
SERIAL_DEV = "/dev/ttyACM0"      # Arduino-Display (ggf. /dev/serial/by-id/... nutzen)
BAUD = 115200                    # muss zum Arduino-Sketch passen
INTERVAL = 3                     # Sekunden zwischen Aktualisierungen
VALHALLA_URL = "http://localhost:8002/route"

_running = False
_stop = False

# ---------------- GPS ----------------
def _get_gps(timeout_s=6):
    """Liest eine gültige GPS-Position (mode 2/3) via gpsd/gpspipe."""
    p = subprocess.Popen(["gpspipe", "-w", "-n", "60"],
                         stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    start = time.time()
    try:
        for raw in p.stdout:
            if time.time() - start > timeout_s:
                break
            try:
                o = json.loads(raw.decode("utf-8", "ignore"))
            except Exception:
                continue
            if o.get("class") == "TPV" and o.get("mode") in (2, 3):
                lat, lon = o.get("lat"), o.get("lon")
                if lat is not None and lon is not None:
                    return float(lat), float(lon)
    finally:
        try:
            p.terminate()
        except Exception:
            pass
    return None

# ---------------- Valhalla ----------------
def _valhalla_first_instruction(cur_lat, cur_lon):
    """Fragt Valhalla und gibt NUR den Text der ersten Manöver-Anweisung zurück."""
    payload = {
        "locations": [{"lat": cur_lat, "lon": cur_lon},
                      {"lat": DST_LAT, "lon": DST_LON}],
        "costing": "auto",
        "directions_options": {"language": "de-DE", "units": "kilometers"}
    }
    if EXCLUDE_TOLLS:
        payload["costing_options"] = {"auto": {"exclude_tolls": True}}

    try:
        res = subprocess.run(
            ["curl", "-s", "-H", "Content-Type: application/json",
             "-X", "POST", VALHALLA_URL, "-d", json.dumps(payload)],
            capture_output=True, text=True, timeout=10
        )
        data = json.loads(res.stdout)
        m = data["trip"]["legs"][0]["maneuvers"][0]
        text = m.get("verbal_pre_transition_instruction", "")
        return text
    except Exception:
        return None

# ---------------- Serial ----------------
def _open_serial_blocking(dev, baud):
    """Öffnet die serielle Schnittstelle, wartet bis das Gerät verfügbar ist."""
    while True:
        try:
            ser = serial.Serial(dev, baud, timeout=2)
            try:
                ser.setDTR(False)  # Auto-Reset vermeiden
            except Exception:
                pass
            time.sleep(2)          # Reset abwarten
            return ser
        except Exception:
            time.sleep(1)

# ---------------- Navigation Loop ----------------
def _nav_loop():
    global _running, _stop
    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
    last_line = None
    print("Navigation gestartet (Loop).")
    try:
        while not _stop:
            fix = _get_gps(timeout_s=6)
            if not fix:
                line = "Kein GPS Empfang"
            else:
                text = _valhalla_first_instruction(*fix)
                line = "Keine Route verfügbar" if not text else text

            if line != last_line:
                try:
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                except Exception:
                    try:
                        ser.close()
                    except Exception:
                        pass
                    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                last_line = line

            time.sleep(INTERVAL)
    finally:
        try:
            ser.close()
        except Exception:
            pass
        _running = False
        _stop = False
        print("Navigation beendet.")

def _start_nav():
    global _running, _stop
    if _running:
        return
    _stop = False
    _running = True
    th = threading.Thread(target=_nav_loop, daemon=True)
    th.start()

# ---------------- GPSD Restart ----------------
def _restart_gpsd():
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd.socket"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print("gpsd neu gestartet")

def _gpsd_button_watcher():
    last = GPIO.input(BTN_GPSD)
    while True:
        cur = GPIO.input(BTN_GPSD)
        # Pull-Up: LOW = gedrückt
        if last == GPIO.HIGH and cur == GPIO.LOW:
            time.sleep(0.05)  # Entprellen
            if GPIO.input(BTN_GPSD) == GPIO.LOW:
                _restart_gpsd()
                while GPIO.input(BTN_GPSD) == GPIO.LOW:
                    time.sleep(0.02)
        last = cur
        time.sleep(0.02)

# ---------------- Main ----------------
def main():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)    # Startknopf
    GPIO.setup(BTN_GPSD, GPIO.IN, pull_up_down=GPIO.PUD_UP)   # GPSD-Knopf

    # Hintergrund-Thread für GPSD-Button starten
    threading.Thread(target=_gpsd_button_watcher, daemon=True).start()

    print("Bereit. Drücke den Button (GPIO 26) um die Navigation zu starten.")

    # Auf Button warten und Navigation starten
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)  # Entprellen
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                print("Button erkannt → starte Navigation.")
                _start_nav()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()

Ich glaube dieses Programm gibt nun rein schriftliche Anweisungen weiter ans Arduino, aber dort muss immer auch der Anweisungstyp vorhanden sein.
Hier das alte Arduino Skript:

#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include <TouchScreen.h>   
#include <U8g2_for_Adafruit_GFX.h>

// ================== Display & Layout ==================
MCUFRIEND_kbv tft;
U8G2_FOR_ADAFRUIT_GFX u8g2;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Auflösung / Layout (Landscape)
const int SCREEN_W = 320;
const int SCREEN_H = 240;

// Bereiche
const int HEADER_H   = 30;
const int MARGIN_X   = 12;
const int TEXT_Y     = HEADER_H + 10;   // Text direkt unter Header

// Fonts (größer, aber noch Uno-kompatibel)
#define FONT_BIG   u8g2_font_helvR18_tf   // ~18 px
#define FONT_SMALL u8g2_font_helvR14_tf   // ~14 px

// ================== Serielle Schnittstelle ==================
const long BAUD = 115200;     // muss zum Pi passen

// ================== Status ==================
String lastInstr = "";

// ---- Hilfsfunktionen ----

// Schätz die Höhe einer Textzeile
int lineHeight(const uint8_t *font) {
  u8g2.setFont(font);
  return u8g2.getFontAscent() - u8g2.getFontDescent() + 2;
}

// Text mit Zeilenumbruch ausgeben
void drawWrappedUTF8(int x, int y, int w, const String &s, const uint8_t *font) {
  u8g2.setFont(font);
  int charH = lineHeight(font);

  String line = "";
  int cx = x, cy = y;
  for (int i = 0; i < (int)s.length(); i++) {
    char c = s[i];
    if (c == '\n') {
      u8g2.setCursor(cx, cy);
      u8g2.print(line);
      line = "";
      cy += charH;
      continue;
    }
    line += c;
    int width = u8g2.getUTF8Width(line.c_str());
    if (width > w) {
      // Zeile ausgeben und umbrechen
      line.remove(line.length() - 1); // letztes Zeichen zurücknehmen
      u8g2.setCursor(cx, cy);
      u8g2.print(line);
      cy += charH;
      line = String(c); // neues Wort mit aktuellem Zeichen
    }
  }
  if (line.length() > 0) {
    u8g2.setCursor(cx, cy);
    u8g2.print(line);
  }
}

// Header anzeigen
void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  u8g2.setFont(FONT_SMALL);
  u8g2.setForegroundColor(WHITE);
  u8g2.setBackgroundColor(BLUE);
  u8g2.setCursor(10, 22);
  u8g2.print("Valhalla Navigation");
}

// ---- Anweisung anzeigen ----
void showInstr(const String &instr) {
  if (instr == lastInstr) return;

  // Textbereich löschen
  int top = TEXT_Y - 2;
  tft.fillRect(0, top, SCREEN_W, SCREEN_H - top, BLACK);

  int availW = SCREEN_W - 2 * MARGIN_X;

  // immer großer Font (passt ins Display)
  drawWrappedUTF8(MARGIN_X, TEXT_Y + 20, availW, instr, FONT_BIG);
  lastInstr = instr;
}

// Eingangszeile säubern (BOM/Steuerzeichen entfernen)
void sanitize(String &s) {
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF &&
      (uint8_t)s[1] == 0xBB &&
      (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) {
    s.remove(0, 1);
  }
  s.replace("\r", "");
}

void setup() {
  Serial.begin(BAUD);

  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);   // Landscape
  tft.fillScreen(BLACK);

  u8g2.begin(tft);      // U8g2 initialisieren
  u8g2.setForegroundColor(WHITE);
  u8g2.setBackgroundColor(BLACK);

  drawHeader();

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() == 0) return;

    showInstr(line);
  }
}


und hier das neue, das aber nicht funktioniert, es ist in zwei Tabs aufgeteilt.
erster Tab, der die Anweisungen verarbeiten soll:

#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // <--- hier kommen deine Bitmaps rein

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F
#define GREEN   0x07E0

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_SIZE = 64;   // 64x64 px Symbole
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

// Icon anhand Code zurückgeben
const unsigned char* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr; // kein Symbol
}

// Text mit Umbruch
void printWrapped(int x, int y, int w, const String &s, uint8_t textSize, uint16_t color) {
  tft.setTextSize(textSize);
  tft.setTextColor(color, BLACK);
  int charW = 6 * textSize;
  int charH = 8 * textSize;
  int maxChars = max(1, w / charW);

  int i = 0;
  while (i < (int)s.length()) {
    int lineEnd = min(i + maxChars, (int)s.length());
    int space = -1;
    for (int j = i; j < lineEnd; j++) if (s[j] == ' ') space = j;
    int cut = (lineEnd == (int)s.length()) ? (int)s.length() : (space >= i ? space : lineEnd);
    String line = s.substring(i, cut);
    tft.setCursor(x, y);
    tft.print(line);
    y += charH + 4;
    i = (space >= i && lineEnd != (int)s.length()) ? space + 1 : cut;
    if (y > SCREEN_H - charH - 6) break;
  }
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// Anzeige von Icon + Text
void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Wir erwarten: "CODE|TEXT"
  int sep = line.indexOf('|');
  String code, text;
  if (sep >= 0) {
    code = line.substring(0, sep);
    text = line.substring(sep + 1);
  } else {
    text = line;
  }

  // Icon anzeigen
  const unsigned char* bmp = iconFromCode(code);
  if (bmp) {
    tft.drawBitmap(MARGIN_X, HEADER_H + 10, bmp, ICON_SIZE, ICON_SIZE, WHITE);
  }

  // Text daneben/unten
  int textX = ICON_SIZE + 2*MARGIN_X;
  int textY = HEADER_H + 20;
  int availW = SCREEN_W - textX - MARGIN_X;
  printWrapped(textX, textY, availW, text, 2, WHITE);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);
  tft.fillScreen(BLACK);
  drawHeader();
  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}

zweiter Tab, der die Piktogramme enthält:
// 'Kreisverkehr2_1', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_2', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x08, 0x30, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_4', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_4 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x01, 0xb0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xb0, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_5', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_5 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_6', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_6 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x0c, 0x38, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_7', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_7 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_3', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_3 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x08, 0x70, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_8', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_8 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x1c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_geradeaus', 64x64px
const unsigned char epd_bitmap_Pfeil_geradeaus [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_9', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_9 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x98, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_links_einspuren', 64x64px
const unsigned char epd_bitmap_Pfeil_links_einspuren [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xcf, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x87, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x0c, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_rechts_abbiegen', 64x64px
const unsigned char epd_bitmap_Pfeil_rechts_abbiegen [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_links_abbiegen', 64x64px
const unsigned char epd_bitmap_Pfeil_links_abbiegen [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_rechts_einspuren', 64x64px
const unsigned char epd_bitmap_Pfeil_rechts_einspuren [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xf3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe1, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x70, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 7392)
const int epd_bitmap_allArray_LEN = 14;
const unsigned char* epd_bitmap_allArray[14] = {
	epd_bitmap_Kreisverkehr2_1,
	epd_bitmap_Kreisverkehr2_2,
	epd_bitmap_Kreisverkehr2_3,
	epd_bitmap_Kreisverkehr2_4,
	epd_bitmap_Kreisverkehr2_5,
	epd_bitmap_Kreisverkehr2_6,
	epd_bitmap_Kreisverkehr2_7,
	epd_bitmap_Kreisverkehr2_8,
	epd_bitmap_Kreisverkehr2_9,
	epd_bitmap_Pfeil_geradeaus,
	epd_bitmap_Pfeil_links_abbiegen,
	epd_bitmap_Pfeil_links_einspuren,
	epd_bitmap_Pfeil_rechts_abbiegen,
	epd_bitmap_Pfeil_rechts_einspuren
};

aktuell funktioniert gerade gar nichts mehr, wie es soll, aber mithilfe der alten Skripts kannst du nachvollziehen was das Ziel ist und kannst alles zusammenfusionieren zu einem, funktionierendem Programm




ChatGPT:

Nachgedacht für 30s
mega-cooles projekt! ✨ ich hab dir beides so zusammengezogen, dass der pi CODE|TEXT zum arduino schickt (inkl. piktogramm-code + optional straßenname + distanz) und der arduino das als symbol + text sauber rendert. robust gegen unbekannte manöver & ohne stress, wenn mal nur text kommt.

1) Raspberry-Pi (Valhalla → „CODE|TEXT“ über UART)
Datei: pi_nav.py
(erweitert dein script: extrahiert manöver-typ, rund­ausfahrt, straßenname, distanz; bildet codes wie LEFT, RIGHT, MERGE_L, MERGE_R, STRAIGHT, RA3 usw.; sendet CODE|TEXT oder nur TEXT als fallback)

# -*- coding: utf-8 -*-
# >>> ZIEL & MAUT (nur diese 3 Zeilen bei Bedarf ändern) <<<
DST_LAT = 47.1662         # Ziel-Breitengrad
DST_LON = 8.5160          # Ziel-Längengrad
EXCLUDE_TOLLS = True      # True = Maut vermeiden, False = Maut erlaubt

# ===== ab hier nichts mehr ändern, außer Port/Baud falls nötig =====
import json, subprocess, time, threading, os, sys, re
import RPi.GPIO as GPIO
import serial

# Hardware/Timing
BTN_PIN   = 26                     # BCM 26 (physischer Pin 37), Taster gegen GND → Start Navigation
BTN_GPSD  = 19                     # BCM 19 (physischer Pin 35), Taster gegen GND → gpsd restart
SERIAL_DEV = "/dev/ttyACM0"        # Arduino-Display (ggf. /dev/serial/by-id/... nutzen)
BAUD       = 115200                # muss zum Arduino-Sketch passen
INTERVAL   = 3                     # Sekunden zwischen Aktualisierungen
VALHALLA_URL = "http://localhost:8002/route"

_running = False
_stop    = False

# ---------------- GPS ----------------
def _get_gps(timeout_s=6):
    """Liest eine gültige GPS-Position (mode 2/3) via gpsd/gpspipe."""
    p = subprocess.Popen(["gpspipe", "-w", "-n", "60"],
                         stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    start = time.time()
    try:
        for raw in p.stdout:
            if time.time() - start > timeout_s:
                break
            try:
                o = json.loads(raw.decode("utf-8", "ignore"))
            except Exception:
                continue
            if o.get("class") == "TPV" and o.get("mode") in (2, 3):
                lat, lon = o.get("lat"), o.get("lon")
                if lat is not None and lon is not None:
                    return float(lat), float(lon)
    finally:
        try: p.terminate()
        except Exception: pass
    return None

# ---------------- Valhalla → CODE|TEXT ----------------
# Valhalla maneuver type (int) → grobe Kategorie
LEFT_TYPES   = {14, 15, 13}                 # left, slight_left, sharp_left
RIGHT_TYPES  = {9, 8, 10}                    # right, slight_right, sharp_right
STRAIGHT_TYPES = {7, 20}                     # continue, stay_straight (häufig 7)
MERGE_TYPES  = {23, 16, 17, 21, 22}          # merge, ramp_right/left, stay_right/left
RA_ENTER     = 24
RA_EXIT      = 25

def _mk_icon_code(m):
    """Erzeugt einen Icon-Code für den ersten Maneuver-Eintrag."""
    t = m.get("type")
    if t in STRAIGHT_TYPES:
        return "STRAIGHT"
    if t in LEFT_TYPES:
        return "LEFT"
    if t in RIGHT_TYPES:
        return "RIGHT"
    if t == RA_EXIT:
        n = int(m.get("roundabout_exit_count", 0)) or 0
        if 1 <= n <= 9:
            return f"RA{n}"
        return "STRAIGHT"  # fallback
    if t == RA_ENTER:
        # beim Einfahren noch keine Ausfahrtzahl → neutrales Kreisverkehr-Symbol:
        return "RA1"
    if t in MERGE_TYPES:
        # links/rechts aus Text ableiten
        txt = (m.get("verbal_pre_transition_instruction") or m.get("instruction") or "").lower()
        if "rechts" in txt:
            return "MERGE_R"
        if "links" in txt:
            return "MERGE_L"
        # manchmal trägt Valhalla die Richtung in "begin_street_names" – schwer abzuleiten -> neutral
        return "STRAIGHT"
    # sonst versuchen, aus Text zu schätzen
    txt = (m.get("verbal_pre_transition_instruction") or "").lower()
    if "kreisverkehr" in txt:
        # Ausfahrtszahl aus Text fischen (1-9)
        mnum = re.search(r"\b([1-9])\.\s*ausfahrt\b", txt)
        if mnum:
            return f"RA{mnum.group(1)}"
        return "RA1"
    if "rechts" in txt:
        return "RIGHT"
    if "links" in txt:
        return "LEFT"
    return "STRAIGHT"

def _nice_distance_km_to_de(dist_km):
    """0.12 km → '120 m', 1.3 km → '1.3 km'"""
    if dist_km is None:
        return None
    try:
        d = float(dist_km)
    except Exception:
        return None
    if d < 0.995:
        return f"{int(round(d*1000))} m"
    return f"{d:.1f} km".replace(".", ",")

def _valhalla_first_code_and_text(cur_lat, cur_lon):
    """Fragt Valhalla und gibt 'CODE|TEXT' (oder nur TEXT) für das erste Manöver zurück."""
    payload = {
        "locations": [{"lat": cur_lat, "lon": cur_lon},
                      {"lat": DST_LAT, "lon": DST_LON}],
        "costing": "auto",
        "directions_options": {"language": "de-DE", "units": "kilometers"}
    }
    if EXCLUDE_TOLLS:
        payload["costing_options"] = {"auto": {"exclude_tolls": True}}

    try:
        res = subprocess.run(
            ["curl", "-s", "-H", "Content-Type: application/json",
             "-X", "POST", VALHALLA_URL, "-d", json.dumps(payload)],
            capture_output=True, text=True, timeout=10
        )
        data = json.loads(res.stdout)
        m = data["trip"]["legs"][0]["maneuvers"][0]

        # Icon-Code
        code = _mk_icon_code(m)

        # Text: Distanz + Straßenname + Verbalinstruktion
        dist = _nice_distance_km_to_de(m.get("length"))              # km → hübsch
        streets = m.get("street_names") or m.get("begin_street_names") or []
        street = streets[0] if streets else None
        verb = m.get("verbal_pre_transition_instruction") or m.get("instruction") or ""

        parts = []
        if dist: parts.append(f"In {dist}")
        if street: parts.append(street)
        # Nur anhängen, wenn der verbale Teil nicht schon Straßennamen/Distanz wiederholt
        if verb:
            parts.append(verb)

        # Doppelungen vermeiden
        text = " – ".join([p for p in parts if p])

        if code:
            return f"{code}|{text}" if text else code
        return text or "Keine Route verfügbar"
    except Exception:
        return None

# ---------------- Serial ----------------
def _open_serial_blocking(dev, baud):
    """Öffnet die serielle Schnittstelle, wartet bis das Gerät verfügbar ist."""
    while True:
        try:
            ser = serial.Serial(dev, baud, timeout=2)
            try: ser.setDTR(False)  # Auto-Reset vermeiden
            except Exception: pass
            time.sleep(2)          # Reset abwarten
            return ser
        except Exception:
            time.sleep(1)

# ---------------- Navigation Loop ----------------
def _nav_loop():
    global _running, _stop
    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
    last_line = None
    print("Navigation gestartet (Loop).")
    try:
        while not _stop:
            fix = _get_gps(timeout_s=6)
            if not fix:
                line = "Kein GPS Empfang"
            else:
                line = _valhalla_first_code_and_text(*fix)
                if not line:
                    line = "Keine Route verfügbar"

            if line != last_line:
                try:
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                except Exception:
                    try: ser.close()
                    except Exception: pass
                    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                last_line = line

            time.sleep(INTERVAL)
    finally:
        try: ser.close()
        except Exception: pass
        _running = False
        _stop = False
        print("Navigation beendet.")

def _start_nav():
    global _running, _stop
    if _running: return
    _stop = False
    _running = True
    threading.Thread(target=_nav_loop, daemon=True).start()

# ---------------- GPSD Restart ----------------
def _restart_gpsd():
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd.socket"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print("gpsd neu gestartet")

def _gpsd_button_watcher():
    last = GPIO.input(BTN_GPSD)
    while True:
        cur = GPIO.input(BTN_GPSD)
        if last == GPIO.HIGH and cur == GPIO.LOW:
            time.sleep(0.05)  # Entprellen
            if GPIO.input(BTN_GPSD) == GPIO.LOW:
                _restart_gpsd()
                while GPIO.input(BTN_GPSD) == GPIO.LOW:
                    time.sleep(0.02)
        last = cur
        time.sleep(0.02)

# ---------------- Main ----------------
def main():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)    # Startknopf
    GPIO.setup(BTN_GPSD, GPIO.IN, pull_up_down=GPIO.PUD_UP)   # GPSD-Knopf
    threading.Thread(target=_gpsd_button_watcher, daemon=True).start()
    print("Bereit. Drücke den Button (GPIO 26) um die Navigation zu starten.")
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                print("Button erkannt → starte Navigation.")
                _start_nav()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()
Was ankommt? Beispiele:

LEFT|In 120 m – Seestraße – Biegen Sie links ab ...

RA3|In 300 m – Kreisverkehr – Nehmen Sie die 3. Ausfahrt ...

STRAIGHT|Folgen Sie der Straße ...

Wenn nur Text möglich: Biegen Sie rechts ab ... (ohne | → Arduino zeigt dann nur Text)

2) Arduino (zeigt Icon + Text)
Struktur (2 Dateien im selben Sketch):

nav_display.ino (Hauptsketch)

bitmaps.h (deine Piktogramme; ich hab die Tabelle beibehalten)

Wichtig:

MCUFRIEND_kbv + Adafruit_GFX bleiben.

Bitmaps sind 1-bit (64×64). drawBitmap kann aus PROGMEM lesen.

Eingabezeile ist CODE|TEXT oder nur TEXT.

Wenn Code unbekannt → nur Text.

nav_display.ino
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine Bitmaps & Array-Namen

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_SIZE = 64;   // 64x64 px Symbole
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

void sanitize(String &s) {
  // UTF-8 BOM + Steuerzeichen entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) {
    s.remove(0, 1);
  }
  s.replace("\r", "");
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// sehr einfache Text-Umbruchausgabe (Adafruit-GFX Font)
void printWrapped(int x, int y, int w, const String &s, uint8_t textSize, uint16_t color) {
  tft.setTextSize(textSize);
  tft.setTextColor(color, BLACK);
  const int charW = 6 * textSize;
  const int charH = 8 * textSize + 2;
  int maxChars = max(1, w / charW);

  int i = 0;
  while (i < (int)s.length()) {
    int lineEnd = min(i + maxChars, (int)s.length());
    int space = -1;
    for (int j = i; j < lineEnd; j++) if (s[j] == ' ') space = j;
    int cut = (lineEnd == (int)s.length()) ? (int)s.length() : (space >= i ? space : lineEnd);
    String line = s.substring(i, cut);
    tft.setCursor(x, y);
    tft.print(line);
    y += charH;
    i = (space >= i && lineEnd != (int)s.length()) ? space + 1 : cut;
    if (y > SCREEN_H - charH - 4) break;
  }
}

// Icon anhand Code zurückgeben
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // "CODE|TEXT" oder nur "TEXT"
  int sep = line.indexOf('|');
  String code, text;
  if (sep >= 0) {
    code = line.substring(0, sep);
    text = line.substring(sep + 1);
  } else {
    text = line;
  }

  // Icon anzeigen (links)
  const uint8_t* bmp = iconFromCode(code);
  int textX = MARGIN_X, textY = HEADER_H + 10;
  if (bmp) {
    // drawBitmap kann PROGMEM 1-bit bitmaps
    tft.drawBitmap(MARGIN_X, HEADER_H + 10, bmp, ICON_SIZE, ICON_SIZE, WHITE);
    textX = ICON_SIZE + 2*MARGIN_X;         // Text rechts daneben
    textY = HEADER_H + 12;
  }

  // Text
  int availW = SCREEN_W - textX - MARGIN_X;
  printWrapped(textX, textY, availW, text, 2, WHITE);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}
bitmaps.h
Nimm einfach deinen bisherigen zweiten Tab 1:1 als bitmaps.h.
Wichtig ist nur, dass die Symbole als const unsigned char ... PROGMEM (oder const uint8_t ... PROGMEM) deklariert sind und die Namen exakt zu den Referenzen im Sketch passen (siehe iconFromCode).

(deine lange Bitmap-Liste habe ich nicht nochmals eingefügt – ersetze die Datei einfach durch deinen Inhalt; die oben benutzten Symbol-Namen stimmen mit deinen überein.)

Schnelltest & Troubleshooting
Seriell-Device: prüfe auf dem Pi mit ls /dev/ttyACM* bzw. /dev/serial/by-id/.... Passe SERIAL_DEV ggf. an.

Baudrate: 115200 auf beiden Seiten gleich.

Valhalla erreichbar: curl -s -X POST http://localhost:8002/route ... sollte JSON liefern.

Bitmaps: sind 64×64, 1-bit. Wenn das Icon „invers“ aussieht, kannst du drawBitmap(..., WHITE) belassen (schwarzer Hintergrund), das passt zu deinen Daten.

Nur Text angekommen? Dann hat der Pi keinen Code ableiten können – Anzeige funktioniert trotzdem.

Roundabout: Bei „Exit“ sendet der Pi RA<n> (1…9), beim „Enter“ RA1 als neutrales Symbol, bis die Ausfahrtszahl bekannt ist.

Wenn du magst, kann ich dir noch weitere Valhalla-Typen mappen (z. B. U-Turn-Symbol, Rampen separat, Ziel erreicht etc.) oder deinen deutschen Text (Distanz/Name/Verb) anders formatieren.

Du:
also muss ich an dem Bitmap Tab nochmals etwas ändern?
ChatGPT:

Nachgedacht für 11s
Kurz: Nein, du musst die Bitmaps nicht neu zeichnen.
Du kannst deinen bisherigen „Bitmap-Tab“ praktisch unverändert verwenden – nur ein paar kleine Orga-Details:

Tab als Header verwenden
– Tab in bitmaps.h umbenennen und ganz oben #pragma once einfügen (oder klassische Include-Guards).
– Optional ganz oben: #include <Arduino.h>.

Typ & PROGMEM ok
– Deine Definitionen als const unsigned char … PROGMEM sind fine. Wenn du magst, kannst du auf const uint8_t … PROGMEM umstellen – ist äquivalent.

Namen müssen passen
Die im Sketch verwendeten Bezeichner existieren bei dir bereits:
epd_bitmap_Pfeil_geradeaus,
epd_bitmap_Pfeil_links_abbiegen, epd_bitmap_Pfeil_rechts_abbiegen,
epd_bitmap_Pfeil_links_einspuren, epd_bitmap_Pfeil_rechts_einspuren,
epd_bitmap_Kreisverkehr2_1 … _9.
→ Kein Änderungsbedarf an den Namen.

Unbenutztes Array optional entfernen
epd_bitmap_allArray brauchst du nicht. Kannst du löschen, spart ein bisschen Flash – schadet aber auch nicht, wenn es drin bleibt.

ICON-Größe
Im Sketch ist ICON_SIZE = 64. Deine Bitmaps sind 64×64 – passt. Nur ändern, falls du andere Größen nutzen willst.

„Inverses“ Weiß/Schwarz?
Falls die Pfeile falschrum wirken, kann man im Sketch bei drawBitmap die Farbe/Background tauschen. Mit deiner aktuellen Datenlage (1-Bit, weiß auf schwarz) passt WHITE auf schwarzem Hintergrund.

Damit reicht: Tab umbenennen → #pragma once → fertig.

Du:
kannst du mir den ganzen Code für das schicken? dort wo ich den Bitmap teil einfügen kannst kannst du einfach schreiben (hier einfügen)
ChatGPT:
Alles klar 👍 – hier der komplette Arduino-Sketch für dein Display.
Du brauchst nur eine Datei (nav_display.ino) und eine zweite Datei bitmaps.h.
In bitmaps.h fügst du deine Bitmaps ein (da steht dann „(hier einfügen)“).

nav_display.ino
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine Bitmaps & Array-Namen

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_SIZE = 64;   // 64x64 px Symbole
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

void sanitize(String &s) {
  // UTF-8 BOM + Steuerzeichen entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) {
    s.remove(0, 1);
  }
  s.replace("\r", "");
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// sehr einfache Text-Umbruchausgabe (Adafruit-GFX Font)
void printWrapped(int x, int y, int w, const String &s, uint8_t textSize, uint16_t color) {
  tft.setTextSize(textSize);
  tft.setTextColor(color, BLACK);
  const int charW = 6 * textSize;
  const int charH = 8 * textSize + 2;
  int maxChars = max(1, w / charW);

  int i = 0;
  while (i < (int)s.length()) {
    int lineEnd = min(i + maxChars, (int)s.length());
    int space = -1;
    for (int j = i; j < lineEnd; j++) if (s[j] == ' ') space = j;
    int cut = (lineEnd == (int)s.length()) ? (int)s.length() : (space >= i ? space : lineEnd);
    String line = s.substring(i, cut);
    tft.setCursor(x, y);
    tft.print(line);
    y += charH;
    i = (space >= i && lineEnd != (int)s.length()) ? space + 1 : cut;
    if (y > SCREEN_H - charH - 4) break;
  }
}

// Icon anhand Code zurückgeben
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // "CODE|TEXT" oder nur "TEXT"
  int sep = line.indexOf('|');
  String code, text;
  if (sep >= 0) {
    code = line.substring(0, sep);
    text = line.substring(sep + 1);
  } else {
    text = line;
  }

  // Icon anzeigen (links)
  const uint8_t* bmp = iconFromCode(code);
  int textX = MARGIN_X, textY = HEADER_H + 10;
  if (bmp) {
    // drawBitmap kann PROGMEM 1-bit bitmaps
    tft.drawBitmap(MARGIN_X, HEADER_H + 10, bmp, ICON_SIZE, ICON_SIZE, WHITE);
    textX = ICON_SIZE + 2*MARGIN_X;         // Text rechts daneben
    textY = HEADER_H + 12;
  }

  // Text
  int availW = SCREEN_W - textX - MARGIN_X;
  printWrapped(textX, textY, availW, text, 2, WHITE);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}
bitmaps.h
#pragma once
#include <Arduino.h>

// Hier deine Bitmap-Definitionen einfügen:
//
// const unsigned char epd_bitmap_Pfeil_geradeaus[] PROGMEM = { ... };
// const unsigned char epd_bitmap_Pfeil_links_abbiegen[] PROGMEM = { ... };
// const unsigned char epd_bitmap_Pfeil_rechts_abbiegen[] PROGMEM = { ... };
// const unsigned char epd_bitmap_Pfeil_links_einspuren[] PROGMEM = { ... };
// const unsigned char epd_bitmap_Pfeil_rechts_einspuren[] PROGMEM = { ... };
// const unsigned char epd_bitmap_Kreisverkehr2_1[] PROGMEM = { ... };
// ...
// const unsigned char epd_bitmap_Kreisverkehr2_9[] PROGMEM = { ... };

👉 Du musst also nur deine vorhandenen Bitmaps (die du bisher im zweiten Tab hattest) in bitmaps.h einfügen.
Danach kompilieren und hochladen – fertig.

Willst du, dass ich dir deine komplette bitmaps.h mit allen Symbolen schon fertig in dieses Format umwandle, so dass du nur Copy-Paste machen musst?

Du:
mein Bitmap Tab sieht nun so aus:
#pragma once
#include <Arduino.h>

const unsigned char epd_bitmap_Kreisverkehr2_1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_2', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x08, 0x30, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_4', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_4 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x01, 0xb0, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xb0, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_5', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_5 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_6', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_6 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x0c, 0x38, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_7', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_7 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_3', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_3 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x08, 0x70, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_8', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_8 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x1c, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_geradeaus', 64x64px
const unsigned char epd_bitmap_Pfeil_geradeaus [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Kreisverkehr2_9', 64x64px
const unsigned char epd_bitmap_Kreisverkehr2_9 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x1f, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x0f, 0xff, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x07, 0x3f, 0xc0, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x07, 0x0f, 0xe0, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x02, 0x03, 0xf0, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x01, 0xf8, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x19, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0xe0, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x98, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x1f, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x9c, 
	0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 
	0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 
	0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x01, 0xf8, 0x00, 
	0x00, 0x0f, 0xc0, 0x40, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x07, 0xe0, 0x40, 0x00, 0x0f, 0xe0, 0x00, 
	0x00, 0x03, 0xf8, 0xe0, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x01, 0xfe, 0xe0, 0x00, 0x7f, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xf0, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x3c, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xf8, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_links_einspuren', 64x64px
const unsigned char epd_bitmap_Pfeil_links_einspuren [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xcf, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x87, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x0c, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_rechts_abbiegen', 64x64px
const unsigned char epd_bitmap_Pfeil_rechts_abbiegen [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf0, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xfe, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xf8, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xe0, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_links_abbiegen', 64x64px
const unsigned char epd_bitmap_Pfeil_links_abbiegen [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x07, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x0f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x03, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// 'Pfeil_rechts_einspuren', 64x64px
const unsigned char epd_bitmap_Pfeil_rechts_einspuren [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xf3, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe1, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x70, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xff, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 7392)
const int epd_bitmap_allArray_LEN = 14;
const unsigned char* epd_bitmap_allArray[14] = {
	epd_bitmap_Kreisverkehr2_1,
	epd_bitmap_Kreisverkehr2_2,
	epd_bitmap_Kreisverkehr2_3,
	epd_bitmap_Kreisverkehr2_4,
	epd_bitmap_Kreisverkehr2_5,
	epd_bitmap_Kreisverkehr2_6,
	epd_bitmap_Kreisverkehr2_7,
	epd_bitmap_Kreisverkehr2_8,
	epd_bitmap_Kreisverkehr2_9,
	epd_bitmap_Pfeil_geradeaus,
	epd_bitmap_Pfeil_links_abbiegen,
	epd_bitmap_Pfeil_links_einspuren,
	epd_bitmap_Pfeil_rechts_abbiegen,
	epd_bitmap_Pfeil_rechts_einspuren
};
ChatGPT:

Nachgedacht für 13s
Sieht super aus – so passt’s zu meinem Sketch. 👍
Ein paar kleine Hinweise, damit alles reibungslos läuft:

Benenne den Tab bitmaps.h (genau so) und lass im Sketch #include "bitmaps.h" stehen.

Die Symbol-Namen stimmen 1:1 mit der iconFromCode(...)-Zuordnung überein (Kreisverkehr2_1…_9, Pfeil_geradeaus, Pfeil_links/_rechts_abbiegen, *_einspuren) – also keine Änderungen nötig.

ICON_SIZE im Sketch ist 64 – deine Bitmaps sind 64×64, passt.

Das Array epd_bitmap_allArray brauchst du im aktuellen Sketch nicht; kannst du drinlassen (unschädlich) oder löschen, um etwas Flash zu sparen.

Wenn du magst, kann ich dir die Roundabout-Codes (RA1–RA9) und Abbiegecodes (LEFT, RIGHT, MERGE_L, MERGE_R, STRAIGHT) nochmal als kurze Test-Strings schicken, damit du per Serial schnell prüfen kannst, ob alle Icons korrekt erscheinen.

Du:
es funktioniert nun grunsätzlich, hat aber noch Verbesserungspotenzial: 
1) Umlaute werden nicht richtig dargestellt, ich glaube das liegt an der Schriftart
2) es wird immernoch ein Fliesstext ausgegeben, statt "In 113m auf Mülitobelstrasse Richtung Norden fahren." würde 113m und Mülitobelstrasse in Richtung Norden in kombination mit dem Pfeil geradeaus reichen
3) Das Piktogramm ist relativ klein, es könnte 1.5 bis doppelt so gross sein
ChatGPT:

Nachgedacht für 27s
Mega — dann schrauben wir’s schnell auf “schön & praktisch”. Drei Punkte:

Umlaute
Mit Adafruit_GFX kommen Umlaute standardmäßig nicht sauber. Einfachste Lösung ohne Font-Bastelei: U8g2-Fonts über die Bridge U8g2_for_Adafruit_GFX nutzen – die haben fertige UTF-8-Schriften inkl. äöüÄÖÜß.

Kompakte Darstellung statt Fließtext
Wir zeigen nur:

großen Pfeil

Distanz fett/groß

Straßenname

darunter klein: “Richtung …”

Piktogramm größer
Ich skaliere dein 64×64-Bitmap per kleinem Nearest-Neighbor-Scaler (Faktor 2 → 128×128). Keine neuen Bitmaps nötig.

Hier ist ein Drop-in-Patch:

Du brauchst einmalig die Library U8g2_for_Adafruit_GFX (über Library Manager installierbar).

Ersetze/ergänze unten markierte Stellen im Sketch. Den Bitmap-Tab lässt du wie er ist.

// --- NEU: Fonts & UTF-8 ---------------------------------
#include <U8g2_for_Adafruit_GFX.h>
U8G2_FOR_ADAFRUIT_GFX u8g2Fonts;   // Bridge-Objekt

// Beispiel: Display-Objekt heißt 'display' (Adafruit_GFX-kompatibel oder GxEPD2)
// In setup() NACH display.begin():
void setup() {
  // ... dein bisheriges setup ...
  u8g2Fonts.begin(display);                 // Bridge starten
  u8g2Fonts.setFontMode(1);                 // Transparenter Font-Draw
  u8g2Fonts.setForegroundColor(EPD_BLACK);  // oder GxEPD_BLACK / BLACK je nach Lib
  u8g2Fonts.setBackgroundColor(EPD_WHITE);  // Hintergrund (für manche Displays egal)
  // eine serifenlose, gut lesbare Vollschrift mit Umlauten:
  u8g2Fonts.setFont(u8g2_font_helvB18_tf);  // fett, ca. 18pt
}

// --- NEU: kleines 1-Bit Bitmap-Scaling (Nearest Neighbor) ---
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t *bmpPROGMEM,
                          uint16_t w, uint16_t h, uint8_t scale, uint16_t color) {
  // liest 1bpp-Bytes aus PROGMEM (wie deine Bitmaps) und zeichnet skaliert
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint16_t byteIndex = (yy * ((w + 7) / 8)) + (xx >> 3);
      uint8_t  bitMask   = 0x80 >> (xx & 7);
      uint8_t  b         = pgm_read_byte(bmpPROGMEM + byteIndex);
      if (b & bitMask) {
        // Pixel ist "1" -> zeichnen, skaliert als Quadrat scale×scale
        display.fillRect(x + xx * scale, y + yy * scale, scale, scale, color);
      }
    }
  }
}

// --- OPTIONAL: kleine Hilfen für Textgrößen -----------------
void setFontLarge()  { u8g2Fonts.setFont(u8g2_font_helvB24_tf); }  // größer für Distanz
void setFontMedium() { u8g2Fonts.setFont(u8g2_font_helvB18_tf); }  // Straßenname
void setFontSmall()  { u8g2Fonts.setFont(u8g2_font_helvR14_tf); }  // Richtung

// --- deine bestehende Icon-Auswahl-Funktion bleibt unverändert ---
// const unsigned char* iconFromCode(const String& code) { ... }

// --- NEU: kompakte Karten-Darstellung ----------------------
void renderNavCompact(const String& distanceMeters,
                      const String& streetName,
                      const String& directionText,
                      const String& iconCode) {
  display.fillScreen(EPD_WHITE); // oder GxEPD_WHITE / WHITE

  // 1) Großes Icon links (Skalierung 2 => 128x128)
  const uint8_t SCALE = 2;           // 2x (kannst du auf 3x erhöhen, wenn Platz)
  const uint16_t ICON_W = 64, ICON_H = 64;
  const int16_t iconX = 8;           // linke Einrückung
  const int16_t iconY = 8;

  const unsigned char* icon = iconFromCode(iconCode);
  drawBitmapScaled1bpp(iconX, iconY, icon, ICON_W, ICON_H, SCALE, EPD_BLACK);

  // 2) Text rechts daneben
  int16_t textAreaX = iconX + ICON_W * SCALE + 12; // etwas Abstand rechts vom Icon
  int16_t cursorY   = iconY + 6;                    // leichte Einrückung nach unten

  // Distanz groß & fett
  setFontLarge();
  u8g2Fonts.setCursor(textAreaX, cursorY + 28);     // Baseline-basiert
  u8g2Fonts.print(distanceMeters);                   // z.B. "113 m"

  // Straßenname mittel
  setFontMedium();
  u8g2Fonts.setCursor(textAreaX, cursorY + 28 + 28); // unter Distanz
  u8g2Fonts.print(streetName);                        // z.B. "Mülitobelstrasse"

  // Richtung klein
  setFontSmall();
  u8g2Fonts.setCursor(textAreaX, cursorY + 28 + 28 + 22);
  u8g2Fonts.print("Richtung ");
  u8g2Fonts.print(directionText);                     // z.B. "Norden"

  // 3) optional: dünne Trennlinie unten
  // display.drawLine(0, display.height()-1, display.width(), display.height()-1, EPD_BLACK);

  display.display(true); // je nach Display-Lib: voll/partial refresh
}

// --- Beispiel, wie du aufrufst (statt Fließtext) -----------
void showNextInstruction() {
  // Diese Strings kommen bei dir ja schon aus dem Parser/Navi:
  String dist = "113 m";
  String street = "Mülitobelstrasse";   // UTF-8: Umlaute funktionieren jetzt
  String dirTxt = "Norden";
  String code = "STRAIGHT";             // oder "RIGHT", "LEFT", "MERGE_R", "RA3", ...

  renderNavCompact(dist, street, dirTxt, code);
}
Hinweise/Optionen
Noch größer? Erhöhe SCALE in renderNavCompact auf 3 (wird dann 192×192). Achte nur auf Display-Größe/Platz.

Zeilenumbrüche: Falls der Straßenname sehr lang ist, können wir eine kleine Auto-Wrap-Funktion ergänzen (sag kurz Bescheid, dann baue ich sie dir direkt ein).

Teilrefresh: Auf E-Paper empfehle ich für diese UI meist Partial Refresh, um Ghosting und Flackern zu reduzieren (je nach Treiber display.displayWindow/display.partialUpdate() o.ä.).

Fallback ohne U8g2: Wenn du partout keine extra Lib willst, kann ich dir eine kleine UTF-8→Latin-1→Umlaut-Ersetzung (ä→ae, ö→oe, ß→ss) reinbauen. Schaut aber weniger hübsch aus.

Wenn du mir sagst, welches genaue Display/Framework du nutzt (GxEPD2? Adafruit EPD? OLED?), passe ich die zwei EPD_BLACK/WHITE und den Refresh-Call exakt auf deine Lib an.

Du:
kannst du den ganzen Arduino Code nochmals geben, sodass ich nur den alten ersetzen muss
ChatGPT:

Nachgedacht für 24s
Alles klar — hier ist ein kompletter, lauffähiger Sketch, den du einfach über deinen alten .ino legen kannst. Deinen Bitmap-Tab lässt du wie er ist; im Code steht an der passenden Stelle (hier einfügen), falls du die Bitmaps lieber direkt in diese Datei kopieren willst.
Voraussetzungen (einmalig über Library Manager installieren):

GxEPD2 (für E-Paper)

U8g2_for_Adafruit_GFX (für UTF-8-Schriften inkl. äöüÄÖÜß)

Falls du ein anderes E-Paper-Modul hast: Nur die eine Display-Zeile mit der richtigen GxEPD2-Panelklasse tauschen (Kommentar im Code).

// =======================
//  Navi-Display (kompakt)
//  - UTF-8 mit U8g2-Fonts (Umlaute ok)
//  - Großes, skaliertes Piktogramm
//  - Distanz / Straße / Richtung als Block (kein Fließtext)
// =======================

#include <Arduino.h>
#include <SPI.h>
#include <GxEPD2_BW.h>                 // E-Paper
#include <U8g2_for_Adafruit_GFX.h>     // UTF-8 Fonts

// ---------- DISPLAY (PINS & PANEL) ----------
// PINS ggf. an dein Board anpassen:
#define EPD_CS   5     // Chip Select
#define EPD_DC   17    // Data/Command
#define EPD_RST  16    // Reset (oder -1, wenn fest verdrahtet)
#define EPD_BUSY 4     // Busy

// Wähle hier dein Panel (Beispiel: 2.9" b/w 296x128, GDEH029A1):
// -> Wenn du ein anderes Display hast, NUR diese Zeile anpassen:
GxEPD2_BW<GxEPD2_290, GxEPD2_290::HEIGHT> display(GxEPD2_290(EPD_CS, EPD_DC, EPD_RST, EPD_BUSY));

// ---------- BITMAPS (hier einfügen ODER separaten Tab verwenden) ----------
// Wenn du deinen Bitmap-Tab bereits hast, brauchst du HIER nichts zu tun.
// Lässt du die Bitmaps separat, dann sorge dafür, dass der Tab in der IDE geöffnet ist.
// Alternativ könntest du auch per #include "Bitmaps.h" einbinden.
// (hier einfügen)

// Falls du die Symbolnamen brauchst, hier die Referenzen (kommen aus deinem Bitmap-Tab):
extern const unsigned char epd_bitmap_Pfeil_geradeaus[];
extern const unsigned char epd_bitmap_Pfeil_links_abbiegen[];
extern const unsigned char epd_bitmap_Pfeil_links_einspuren[];
extern const unsigned char epd_bitmap_Pfeil_rechts_abbiegen[];
extern const unsigned char epd_bitmap_Pfeil_rechts_einspuren[];
extern const unsigned char epd_bitmap_Kreisverkehr2_1[];
extern const unsigned char epd_bitmap_Kreisverkehr2_2[];
extern const unsigned char epd_bitmap_Kreisverkehr2_3[];
extern const unsigned char epd_bitmap_Kreisverkehr2_4[];
extern const unsigned char epd_bitmap_Kreisverkehr2_5[];
extern const unsigned char epd_bitmap_Kreisverkehr2_6[];
extern const unsigned char epd_bitmap_Kreisverkehr2_7[];
extern const unsigned char epd_bitmap_Kreisverkehr2_8[];
extern const unsigned char epd_bitmap_Kreisverkehr2_9[];

// ---------- UTF-8 Fonts Bridge ----------
U8G2_FOR_ADAFRUIT_GFX u8g2;

// ---------- Utility: 1bpp Bitmap skaliert zeichnen ----------
static void drawBitmapScaled1bpp(
  int16_t x, int16_t y,
  const uint8_t* bmpPROGMEM,
  uint16_t w, uint16_t h,
  uint8_t scale,
  uint16_t color
) {
  const uint16_t rowBytes = (w + 7) / 8;
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint16_t byteIndex = yy * rowBytes + (xx >> 3);
      uint8_t  bitMask   = 0x80 >> (xx & 7);
      uint8_t  b         = pgm_read_byte(bmpPROGMEM + byteIndex);
      if (b & bitMask) {
        display.fillRect(x + xx * scale, y + yy * scale, scale, scale, color);
      }
    }
  }
}

// ---------- Fonts schnell wechseln ----------
inline void setFontLarge()  { u8g2.setFont(u8g2_font_helvB24_tf); }  // Distanz
inline void setFontMedium() { u8g2.setFont(u8g2_font_helvB18_tf); }  // Straßenname
inline void setFontSmall()  { u8g2.setFont(u8g2_font_helvR14_tf); }  // Richtung

// ---------- Icon-Auswahl ----------
const unsigned char* iconFromCode(const String& code, uint8_t frame = 1) {
  // code: "STRAIGHT", "LEFT", "RIGHT", "MERGE_L", "MERGE_R", "RA" (Kreisverkehr)
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;

  // Kreisverkehr animierbar: frame 1..9
  if (code == "RA") {
    switch (frame) {
      case 1:  return epd_bitmap_Kreisverkehr2_1;
      case 2:  return epd_bitmap_Kreisverkehr2_2;
      case 3:  return epd_bitmap_Kreisverkehr2_3;
      case 4:  return epd_bitmap_Kreisverkehr2_4;
      case 5:  return epd_bitmap_Kreisverkehr2_5;
      case 6:  return epd_bitmap_Kreisverkehr2_6;
      case 7:  return epd_bitmap_Kreisverkehr2_7;
      case 8:  return epd_bitmap_Kreisverkehr2_8;
      case 9:  return epd_bitmap_Kreisverkehr2_9;
      default: return epd_bitmap_Kreisverkehr2_1;
    }
  }
  // Fallback
  return epd_bitmap_Pfeil_geradeaus;
}

// ---------- Layoutrender: kompaktes Navi ----------
// Zeigt: großes Icon + Distanz (groß) + Straße (mittel) + "Richtung X" (klein)
void renderNavCompact(
  const String& distanceMeters,    // z.B. "113 m"
  const String& streetName,        // z.B. "Mülitobelstrasse"
  const String& directionText,     // z.B. "Norden"
  const String& iconCode,          // z.B. "STRAIGHT", "LEFT", "RIGHT", "MERGE_R", "RA"
  uint8_t raFrame = 1,             // Kreisverkehr-Frame 1..9 (für Animation)
  uint8_t iconScale = 2            // 2 = 128×128 aus 64×64; 3 = 192×192
) {
  display.setFullWindow();                 // volle Fläche
  display.firstPage();
  do {
    display.fillScreen(GxEPD_WHITE);

    // --- Icon links groß ---
    const uint16_t ICON_W = 64, ICON_H = 64;
    const int16_t  iconX  = 8;
    const int16_t  iconY  = 8;
    const unsigned char* icon = iconFromCode(iconCode, raFrame);
    drawBitmapScaled1bpp(iconX, iconY, icon, ICON_W, ICON_H, iconScale, GxEPD_BLACK);

    // --- Text rechts daneben ---
    const int16_t textX = iconX + ICON_W * iconScale + 12;
    int16_t baseline = iconY + 6;

    // Distanz groß
    setFontLarge();
    u8g2.setCursor(textX, baseline + 28);
    u8g2.print(distanceMeters);

    // Straße mittel (bei sehr langen Namen ggf. Auto-Kürzung)
    String street = streetName;
    // Simple Kürzung falls zu breit: (optional verfeinern)
    int16_t bx, by; uint16_t bw, bh;
    u8g2.getUTF8Width(street.c_str()); // Warmup
    while (street.length() > 3) {
      u8g2.setFont(u8g2_font_helvB18_tf);
      uint16_t w = u8g2.getUTF8Width(street.c_str());
      if (textX + (int)w < (int)display.width() - 6) break;
      street.remove(street.length() - 1);
      street += "...";
      if (street.endsWith("......")) { street = streetName.substring(0, 10) + "..."; break; }
    }

    setFontMedium();
    u8g2.setCursor(textX, baseline + 28 + 28);
    u8g2.print(street);

    // Richtung klein
    setFontSmall();
    u8g2.setCursor(textX, baseline + 28 + 28 + 22);
    u8g2.print("Richtung ");
    u8g2.print(directionText);

    // Optional: feine Bodenlinie
    // display.drawLine(0, display.height() - 1, display.width(), display.height() - 1, GxEPD_BLACK);

  } while (display.nextPage());
}

// ---------- DEMO: Beispielanweisung ----------
void showDemo() {
  // Beispiel: Geradeaus in 113 m, Straße "Mülitobelstrasse", Richtung Norden
  renderNavCompact("113 m", "Mülitobelstrasse", "Norden", "STRAIGHT", /*raFrame*/1, /*iconScale*/2);
  // Für Kreisverkehr-Animation könntest du nacheinander raFrame 1..9 rendern.
}

// ---------- SETUP ----------
void setup() {
  // Serial optional
  // Serial.begin(115200);

  // E-Paper init
  display.init(115200); // SPI + EPD init (Baudrate ggf. anpassen)

  // U8g2-Bridge für UTF-8 starten
  u8g2.begin(display);
  u8g2.setFontMode(1);                       // transparent
  u8g2.setForegroundColor(GxEPD_BLACK);
  u8g2.setBackgroundColor(GxEPD_WHITE);

  // DEMO zeigen (du rufst später renderNavCompact(...) mit echten Daten)
  showDemo();
}

// ---------- LOOP ----------
void loop() {
  // Hier würdest du neue Navigationsdaten verarbeiten
  // und renderNavCompact(...) erneut aufrufen (Partial Updates optional).
  // Für E-Paper eher ereignisgetrieben als schnell wiederholen.
}
Was ist jetzt besser?
Umlaute: kommen sauber, weil die U8g2-Fonts UTF-8 können.

Kompakt statt Fließtext: Distanz groß, Straßenname, darunter „Richtung …“ – fertig.

Piktogramm groß: per iconScale auf 2× (128×128) gesetzt; stell auf 3, wenn’s noch größer sein soll.

Wenn du mir kurz sagst, welches genaue E-Paper-Modul (Panel-Bezeichnung) und Board du nutzt, setze ich dir die eine Display-Zeile und die Pins exakt passend ein.

Du:
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2\Display_Graphisch_v2.ino:10:10: fatal error: GxEPD2_BW.h: No such file or directory
compilation terminated.
exit status 1

Compilation error: GxEPD2_BW.h: No such file or directory
ChatGPT:
Ah 👍, die Fehlermeldung heißt einfach: die Library GxEPD2 fehlt bei dir noch.
Die Datei GxEPD2_BW.h gehört zu dieser Library.

So installierst du sie:

Öffne die Arduino IDE.

Menü Werkzeuge → Bibliotheken verwalten….

Suche nach GxEPD2.

Installiere die Library „GxEPD2 by Jean-Marc Zingg“.

Danach kannst du auch gleich noch die Schriftart-Bridge installieren:

Wieder im Bibliotheksverwalter nach U8g2_for_Adafruit_GFX suchen.

Installieren.

Jetzt sollte der Sketch sauber kompilieren.

👉 Frage an dich: welches E-Paper Display-Modell nutzt du (z. B. Waveshare 2.9″, 4.2″, 7.5″ …)?
Dann kann ich dir die richtige GxEPD2-Panelklasse direkt eintragen, sodass du nichts mehr suchen musst.

Du:
C:\Users\simir\AppData\Local\Temp\cc5sXwYL.ltrans0.ltrans.o: In function main':
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:79: undefined reference to epd_bitmap_Pfeil_links_abbiegen'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:79: undefined reference to epd_bitmap_Pfeil_links_abbiegen'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:80: undefined reference to epd_bitmap_Pfeil_rechts_abbiegen'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:80: undefined reference to epd_bitmap_Pfeil_rechts_abbiegen'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:81: undefined reference to epd_bitmap_Pfeil_links_einspuren'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:81: undefined reference to epd_bitmap_Pfeil_links_einspuren'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:82: undefined reference to epd_bitmap_Pfeil_rechts_einspuren'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:82: undefined reference to epd_bitmap_Pfeil_rechts_einspuren'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:87: undefined reference to epd_bitmap_Kreisverkehr2_1'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:87: undefined reference to epd_bitmap_Kreisverkehr2_1'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:78: undefined reference to epd_bitmap_Pfeil_geradeaus'
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v2/Display_Graphisch_v2.ino:78: undefined reference to epd_bitmap_Pfeil_geradeaus'
collect2.exe: error: ld returned 1 exit status
exit status 1

Compilation error: exit status 1
ChatGPT:

Nachgedacht für 19s
Der Linker findet deine Bitmap-Symbole nicht – d. h. die Datei mit den Definitionen der Arrays wird nicht (richtig) mitgebaut bzw. nicht eingebunden.

Mach’s so, dann ist es narrensicher:

Variante A (am einfachsten)
Benenne deinen Bitmap-Tab ohne Leerzeichen/Ümlaute z. B. bitmaps.ino.

Lass in diesem Tab genau die Definitionen stehen (so wie du sie oben gepostet hast, inkl. der großen Byte-Arrays und des epd_bitmap_allArray).

In der Haupt-.ino brauchst du nichts zu extern-deklarieren – die Symbole sind projektweit sichtbar.

Häufiger Fehler: Der Tab heißt *.h (Header) und wird nicht #included → dann fehlen die Definitionen beim Linken.

Variante B (sauber mit Header + Quelle)
Lege zwei neue Tabs an:

bitmaps.h

bitmaps.cpp (oder bitmaps.ino)

Inhalt bitmaps.h (nur Deklarationen):

#pragma once
#include <Arduino.h>

extern const unsigned char epd_bitmap_Pfeil_geradeaus[] PROGMEM;
extern const unsigned char epd_bitmap_Pfeil_links_abbiegen[] PROGMEM;
extern const unsigned char epd_bitmap_Pfeil_rechts_abbiegen[] PROGMEM;
extern const unsigned char epd_bitmap_Pfeil_links_einspuren[] PROGMEM;
extern const unsigned char epd_bitmap_Pfeil_rechts_einspuren[] PROGMEM;
extern const unsigned char epd_bitmap_Kreisverkehr2_1[] PROGMEM;
// falls du weitere direkt benutzt: hier ergänzen …

extern const int epd_bitmap_allArray_LEN;
extern const unsigned char* epd_bitmap_allArray[];
Inhalt bitmaps.cpp (die Definitionen – einfach deinen kompletten Bitmap-Tab hier reinkopieren):

#include <Arduino.h>
#include "bitmaps.h"

// >>> Hier deinen gesamten geposteten Bitmap-Content einfügen
// (alle const unsigned char … PROGMEM = { … }; sowie
//  epd_bitmap_allArray_LEN und epd_bitmap_allArray)
// <<< Ende Einfügen
Oben in deiner Hauptdatei Display_Graphisch_v2.ino:

#include "bitmaps.h"
Wichtig:

Kein Tab-Name mit Leerzeichen/Ümlauten. Nimm bitmaps.h / bitmaps.cpp.

Entweder Definitionen oder Deklarationen im Header – nicht beides.

Wenn du Variante B nutzt, darf es keine weiteren extern-Zeilen irgendwo geben, die anders lauten.

Damit verschwinden die „undefined reference“-Fehler für:

epd_bitmap_Pfeil_geradeaus

epd_bitmap_Pfeil_links_abbiegen

epd_bitmap_Pfeil_rechts_abbiegen

epd_bitmap_Pfeil_links_einspuren

epd_bitmap_Pfeil_rechts_einspuren

epd_bitmap_Kreisverkehr2_1
… und alle übrigen, die du verwendest.

Wenn es danach noch meckert, sag mir bitte wie genau dein Bitmap-Tab heißt und ob du ihn als .h, .cpp oder .ino angelegt hast – dann passe ich dir die Includes 1:1 an.

Du:
Der Sketch verwendet 36612 Bytes (113%) des Programmspeicherplatzes. Das Maximum sind 32256 Bytes.
Globale Variablen verwenden 5449 Bytes (266%) des dynamischen Speichers, -3401 Bytes für lokale Variablen verbleiben. Das Maximum sind 2048 Bytes.
Der Sketch ist zu groß; unter https://support.arduino.cc/hc/en-us/articles/360013825179 finden sich Hinweise, um die Größe zu verringern.
Textbereich überschreitet den verfügbaren Platz auf der Platine

Compilation error: Textbereich überschreitet den verfügbaren Platz auf der Platine
ChatGPT:
Du läufst in Flash- (113%) und RAM-Überlauf (266%) – für einen UNO/Nano (ATmega328P) viel zu fett. Das liegt an: vielen Bitmaps, großen Fonts und (vermutlich) einem Voll-Framebuffer. So bekommst du’s schlank:

Sofort-Fix (passt meist auf den UNO)
Paged Buffer aktivieren (dramatisch weniger RAM)
Ersetze deine Display-Instanz so, dass nur eine kleine Seitenhöhe gepuffert wird (16–32 Pixel). Beispiel (bitte auf dein Panel-Typ anpassen – nur das zweite Template-Argument ist wichtig!):

// statt: GxEPD2_BW<GxEPD2_213_B72, GxEPD2_213_B72::HEIGHT> display(...);
GxEPD2_BW<GxEPD2_213_B72, 16> display(/*CS=*/ SS, /*DC=*/ 8, /*RST=*/ 9, /*BUSY=*/ 7);
Und ALLES Zeichnen so aufrufen:

display.setFullWindow();
display.firstPage();
do {
  drawScreen();   // <- deine Zeichenfunktion
} while (display.nextPage());
(Ohne firstPage/nextPage nutzt GxEPD2 gern den großen Buffer → RAM-Überlauf.)

Strings in Flash legen
Alle Konstanten in F() hüllen:

display.print(F("m"));
display.println(F(" in Richtung Norden"));
Große Fonts raus
Nur die Standard-GFX-Schrift oder sehr kleine GFX-Fonts verwenden. Alles wie FreeSansBold24pt7b etc. löschen/auskommentieren.

Bitmaps abspecken

Lass nur die wirklich verwendeten Pfeile im Projekt.

Runde/Animation: auf 1–3 Frames reduzieren (statt 9).

Optional auf 48×48 oder 32×32 runterskalieren (spart Flash).

Header & PROGMEM korrekt

Definitions nur einmal in bitmaps.cpp (oder bitmaps.ino) mit PROGMEM.

In bitmaps.h nur extern … PROGMEM;

Keine doppelten Definitionen (sonst wächst der Code unnötig).

Wenn es trotzdem knapp bleibt
Board mit mehr Flash/RAM nutzen (Mega2560, Nano Every, oder gleich ESP32 – GxEPD2 läuft dort super).

Alternativ: statt GxEPD2 eine reine Seiten-API (keine Vollpuffer) und kleinere Fonts/Bitmaps.

Mini-Beispiel (pures Gerüst, sehr klein)
Dieses Grundgerüst nutzt Paged-Mode, Standardfont, einen Bitmap-Pfeil und kurze Texte (du musst nur deinen Display-Typ und Pins einsetzen und genau 1 Pfeil-Bitmap behalten).

#include <GxEPD2_BW.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // nur extern-Deklarationen!

// WICHTIG: Dein Panel-Typ + kleine Seitenhöhe (16)
GxEPD2_BW<GxEPD2_213_B72, 16> display(/*CS=*/ SS, /*DC=*/ 8, /*RST=*/ 9, /*BUSY=*/ 7);

void drawScreen(const char* dist, const char* strasse, const char* richtung) {
  display.fillScreen(GxEPD_WHITE);
  display.setTextColor(GxEPD_BLACK);
  display.setCursor(0, 14);
  display.print(dist); display.println(F("m"));

  display.setCursor(0, 28);
  display.print(strasse);

  display.setCursor(0, 42);
  display.print(F("Richtung "));
  display.print(richtung);

  // Pfeil größer zeichnen: 96x96 statt 64x64 (Skalierung per drawBitmap nicht möglich → nimm 1:1
  // und zeichne ihn einfach "dominant" im Layout; oder erzeuge eine größere Version offline)
  // Hier 64x64 in die Ecke:
  display.drawBitmap(128-64, 0, epd_bitmap_Pfeil_geradeaus, 64, 64, GxEPD_BLACK);
}

void setup() {
  display.init();
  display.setRotation(1);
  display.setFullWindow();

  display.firstPage();
  do {
    drawScreen("113", "Mülitobelstrasse", "Norden");
  } while (display.nextPage());
}

void loop() {}
Tipp zur Bitmap-Größe: Wenn du das Piktogramm „1.5–2× größer“ willst, erzeuge offline eine 96×96 oder 128×128 Bitmap und ersetze die 64×64-Daten. Laufzeit-Skalierung gibt’s hier nicht kostenlos.

Wenn du willst, sag mir kurz:

Welches genaue EPD-Panel (Modell) du nutzt

Welche Pfeile du wirklich brauchst
Dann schneide ich dir deinen Sketch UNO-tauglich zu (Paged-Mode + schlanke Bitmaps), damit er sicher in 32 KB/2 KB passt.

Du:
gib mir das ganze Skript mit den Anpassungen von eben
ChatGPT:

Nachgedacht für 16s
Hier ist ein kompletter, schlanker Sketch (eine einzelne .ino-Datei), der:

im Paged-Mode zeichnet (RAM-freundlich),

Umlaute automatisch in ASCII umschreibt (ü→ue, ä→ae, ß→ss …),

nur einen Pfeil (geradeaus) als Bitmap nutzt,

kurze Ausgabe macht: „113 m“, „Muelitobelstrasse“, „Richtung Norden“,

das Piktogramm prominent (64×64) rechts anzeigt.

Falls du ein anderes E-Paper-Panel hast, ändere nur die Display-Klasse in Zeile mit GxEPD2_213_B72 (Beispiele siehe GxEPD2-Library). Page-Höhe 16 lassen.

/*
  Display_Graphisch_v3.ino – schlanke Version
  - Paged Mode (firstPage/nextPage)
  - Umlaut-Ersatz (UTF-8 -> ASCII)
  - Kurze Anzeige + großes Piktogramm rechts
  Abhängigkeiten: GxEPD2, Adafruit_GFX
*/

#include <GxEPD2_BW.h>
#include <Adafruit_GFX.h>

// -----------------------------
// PANEL & PINS (ANPASSEN, falls nötig)
// Beispiel: Waveshare 2.13" b/w V2 (GxEPD2_213_B72)
// -----------------------------
// Pins: CS=SS, DC=8, RST=9, BUSY=7 – bei Bedarf an dein Board anpassen
GxEPD2_BW<GxEPD2_213_B72, 16> display(/*CS=*/ SS, /*DC=*/ 8, /*RST=*/ 9, /*BUSY=*/ 7);

// -----------------------------
// BITMAPS (nur was gebraucht wird)
// 64x64 Pfeil geradeaus, 1-Bit, PROGMEM
// -----------------------------
const unsigned char epd_bitmap_Pfeil_geradeaus [] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xc0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x07,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x1f,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xfc,0x00,0x00,0x00,
  0x00,0x00,0x00,0x7f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,
  0x00,0x00,0x01,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x03,0xff,0xff,0xc0,0x00,0x00,
  0x00,0x00,0x07,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x0f,0xff,0xff,0xf0,0x00,0x00,
  0x00,0x00,0x1f,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x3f,0xff,0xff,0xfc,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

// -----------------------------
// UTF-8 → ASCII (Umlaute ersetzen, damit GFX-Font sie zeigt)
// ersetze: ä→ae, ö→oe, ü→ue, Ä→Ae, Ö→Oe, Ü→Ue, ß→ss
// -----------------------------
void normalizeUmlauts(const char* in, char* out, size_t outSize)
{
  size_t o = 0;
  for (size_t i = 0; in[i] != '\0' && o + 1 < outSize; )
  {
    uint8_t c = (uint8_t)in[i];

    if (c == 0xC3 && in[i+1] != '\0') {
      uint8_t d = (uint8_t)in[i+1];
      const char* repl = nullptr;

      switch (d) {
        case 0xA4: repl = "ae"; break; // ä
        case 0xB6: repl = "oe"; break; // ö
        case 0xBC: repl = "ue"; break; // ü
        case 0x84: repl = "Ae"; break; // Ä
        case 0x96: repl = "Oe"; break; // Ö
        case 0x9C: repl = "Ue"; break; // Ü
        case 0x9F: repl = "ss"; break; // ß
      }

      if (repl) {
        while (*repl && o + 1 < outSize) out[o++] = *repl++;
        i += 2;
        continue;
      }
    }

    // normal kopieren
    out[o++] = in[i++];
  }
  out[o] = '\0';
}

// -----------------------------
// Zeichenroutine (eine Seite – wird per firstPage/nextPage wiederholt)
// -----------------------------
void drawScreen(const char* dist_m, const char* strasse_utf8, const char* richtung_utf8)
{
  // Umlaut-ersetzte Puffer
  char strasse[64];   normalizeUmlauts(strasse_utf8, strasse, sizeof(strasse));
  char richtung[32];  normalizeUmlauts(richtung_utf8, richtung, sizeof(richtung));

  const int W = display.width();
  const int H = display.height();

  display.fillScreen(GxEPD_WHITE);
  display.setTextColor(GxEPD_BLACK);
  display.setTextSize(1);       // kleine, eingebaute Schrift (sehr RAM-sparend)
  display.setCursor(8, 18);

  // Zeile 1: Distanz groß (zwei Zeilen für bessere Lesbarkeit)
  display.setTextSize(2);
  display.print(dist_m);
  display.print(F(" m"));

  // Zeile 2: Straßenname
  display.setTextSize(1);
  display.setCursor(8, 38);
  display.print(strasse);

  // Zeile 3: Richtung
  display.setCursor(8, 54);
  display.print(F("Richtung "));
  display.print(richtung);

  // Pfeil rechts groß zeichnen (64x64). Für „1.5–2×“ größer:
  // -> Offline eine 96×96 oder 128×128 Bitmap erzeugen und hier ersetzen.
  const int bmpW = 64, bmpH = 64;
  int bmpX = W - bmpW - 8;   // rechtsbündig mit Rand
  int bmpY = (H - bmpH) / 2; // vertikal mittig
  if (bmpY < 0) bmpY = 0;

  display.drawBitmap(bmpX, bmpY, epd_bitmap_Pfeil_geradeaus, bmpW, bmpH, GxEPD_BLACK);
}

// -----------------------------
// Setup/Loop
// -----------------------------
void setup()
{
  display.init();
  display.setRotation(1);   // Querformat (je nach Panel/Layout)
  display.setFullWindow();

  // Beispielwerte (hier einsetzen, später aus deiner Logik füllen)
  const char* dist   = "113";
  const char* str    = "M\u00FClitobelstrasse"; // „Mülitobelstrasse“ in UTF-8
  const char* richt  = "Norden";

  display.firstPage();
  do {
    drawScreen(dist, str, richt);
  } while (display.nextPage());
}

void loop()
{
  // E-Paper: nichts zu tun, bis neue Daten kommen.
}
Hinweise
Bitmap größer: Runtime-Skalierung gibt’s hier nicht „gratis“. Um das Piktogramm 1.5–2× größer zu machen, erzeug’ offline (z. B. mit LCD-Image-Converter) eine 96×96 oder 128×128 Version deines Pfeils und ersetze epd_bitmap_Pfeil_geradeaus + Breite/Höhe im Code.

Mehr Piktogramme: Wenn du weitere Pfeile brauchst, füge sie genauso als const unsigned char … PROGMEM hinzu und rufe das passende in drawScreen() auf. Achte darauf, nur die benötigten Bitmaps einzubinden (spart Flash).

Anderes Panel: Nutzt du nicht das 2.13" B72, ersetze GxEPD2_213_B72 durch deinen Panel-Typ (siehe GxEPD2_Example in der Library). Die 16 ist die Seitenhöhe (klein halten für geringen RAM-Verbrauch).

Wenn du mir noch dein exaktes Display-Modell und welche Pfeile du wirklich brauchst sagst, bastle ich dir direkt die passende(n) Bitmaps rein (z. B. 96×96) – weiterhin schlank genug für den UNO.

Du:
irgendwie funktioniert gerade gar nichts mehr, gehen wir also zurück zum Punkt als alles noch funktioniert hat: // // =======================
//  Navi-Display (kompakt)
//  - UTF-8 mit U8g2-Fonts (Umlaute ok)
//  - Großes, skaliertes Piktogramm
//  - Distanz / Straße / Richtung als Block (kein Fließtext)
// =======================

#include <Arduino.h>
#include <SPI.h>
#include <GxEPD2_BW.h>                 // E-Paper
#include <U8g2_for_Adafruit_GFX.h>     // UTF-8 Fonts

// ---------- DISPLAY (PINS & PANEL) ----------
// PINS ggf. an dein Board anpassen:
#define EPD_CS   5     // Chip Select
#define EPD_DC   17    // Data/Command
#define EPD_RST  16    // Reset (oder -1, wenn fest verdrahtet)
#define EPD_BUSY 4     // Busy

// Wähle hier dein Panel (Beispiel: 2.9" b/w 296x128, GDEH029A1):
// -> Wenn du ein anderes Display hast, NUR diese Zeile anpassen:
GxEPD2_BW<GxEPD2_290, GxEPD2_290::HEIGHT> display(GxEPD2_290(EPD_CS, EPD_DC, EPD_RST, EPD_BUSY));

// ---------- BITMAPS (hier einfügen ODER separaten Tab verwenden) ----------
// Wenn du deinen Bitmap-Tab bereits hast, brauchst du HIER nichts zu tun.
// Lässt du die Bitmaps separat, dann sorge dafür, dass der Tab in der IDE geöffnet ist.
// Alternativ könntest du auch per #include "Bitmaps.h" einbinden.
// (hier einfügen)

// Falls du die Symbolnamen brauchst, hier die Referenzen (kommen aus deinem Bitmap-Tab):
extern const unsigned char epd_bitmap_Pfeil_geradeaus[];
extern const unsigned char epd_bitmap_Pfeil_links_abbiegen[];
extern const unsigned char epd_bitmap_Pfeil_links_einspuren[];
extern const unsigned char epd_bitmap_Pfeil_rechts_abbiegen[];
extern const unsigned char epd_bitmap_Pfeil_rechts_einspuren[];
extern const unsigned char epd_bitmap_Kreisverkehr2_1[];
extern const unsigned char epd_bitmap_Kreisverkehr2_2[];
extern const unsigned char epd_bitmap_Kreisverkehr2_3[];
extern const unsigned char epd_bitmap_Kreisverkehr2_4[];
extern const unsigned char epd_bitmap_Kreisverkehr2_5[];
extern const unsigned char epd_bitmap_Kreisverkehr2_6[];
extern const unsigned char epd_bitmap_Kreisverkehr2_7[];
extern const unsigned char epd_bitmap_Kreisverkehr2_8[];
extern const unsigned char epd_bitmap_Kreisverkehr2_9[];

// ---------- UTF-8 Fonts Bridge ----------
U8G2_FOR_ADAFRUIT_GFX u8g2;

// ---------- Utility: 1bpp Bitmap skaliert zeichnen ----------
static void drawBitmapScaled1bpp(
  int16_t x, int16_t y,
  const uint8_t* bmpPROGMEM,
  uint16_t w, uint16_t h,
  uint8_t scale,
  uint16_t color
) {
  const uint16_t rowBytes = (w + 7) / 8;
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint16_t byteIndex = yy * rowBytes + (xx >> 3);
      uint8_t  bitMask   = 0x80 >> (xx & 7);
      uint8_t  b         = pgm_read_byte(bmpPROGMEM + byteIndex);
      if (b & bitMask) {
        display.fillRect(x + xx * scale, y + yy * scale, scale, scale, color);
      }
    }
  }
}

// ---------- Fonts schnell wechseln ----------
inline void setFontLarge()  { u8g2.setFont(u8g2_font_helvB24_tf); }  // Distanz
inline void setFontMedium() { u8g2.setFont(u8g2_font_helvB18_tf); }  // Straßenname
inline void setFontSmall()  { u8g2.setFont(u8g2_font_helvR14_tf); }  // Richtung

// ---------- Icon-Auswahl ----------
const unsigned char* iconFromCode(const String& code, uint8_t frame = 1) {
  // code: "STRAIGHT", "LEFT", "RIGHT", "MERGE_L", "MERGE_R", "RA" (Kreisverkehr)
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;

  // Kreisverkehr animierbar: frame 1..9
  if (code == "RA") {
    switch (frame) {
      case 1:  return epd_bitmap_Kreisverkehr2_1;
      case 2:  return epd_bitmap_Kreisverkehr2_2;
      case 3:  return epd_bitmap_Kreisverkehr2_3;
      case 4:  return epd_bitmap_Kreisverkehr2_4;
      case 5:  return epd_bitmap_Kreisverkehr2_5;
      case 6:  return epd_bitmap_Kreisverkehr2_6;
      case 7:  return epd_bitmap_Kreisverkehr2_7;
      case 8:  return epd_bitmap_Kreisverkehr2_8;
      case 9:  return epd_bitmap_Kreisverkehr2_9;
      default: return epd_bitmap_Kreisverkehr2_1;
    }
  }
  // Fallback
  return epd_bitmap_Pfeil_geradeaus;
}

// ---------- Layoutrender: kompaktes Navi ----------
// Zeigt: großes Icon + Distanz (groß) + Straße (mittel) + "Richtung X" (klein)
void renderNavCompact(
  const String& distanceMeters,    // z.B. "113 m"
  const String& streetName,        // z.B. "Mülitobelstrasse"
  const String& directionText,     // z.B. "Norden"
  const String& iconCode,          // z.B. "STRAIGHT", "LEFT", "RIGHT", "MERGE_R", "RA"
  uint8_t raFrame = 1,             // Kreisverkehr-Frame 1..9 (für Animation)
  uint8_t iconScale = 2            // 2 = 128×128 aus 64×64; 3 = 192×192
) {
  display.setFullWindow();                 // volle Fläche
  display.firstPage();
  do {
    display.fillScreen(GxEPD_WHITE);

    // --- Icon links groß ---
    const uint16_t ICON_W = 64, ICON_H = 64;
    const int16_t  iconX  = 8;
    const int16_t  iconY  = 8;
    const unsigned char* icon = iconFromCode(iconCode, raFrame);
    drawBitmapScaled1bpp(iconX, iconY, icon, ICON_W, ICON_H, iconScale, GxEPD_BLACK);

    // --- Text rechts daneben ---
    const int16_t textX = iconX + ICON_W * iconScale + 12;
    int16_t baseline = iconY + 6;

    // Distanz groß
    setFontLarge();
    u8g2.setCursor(textX, baseline + 28);
    u8g2.print(distanceMeters);

    // Straße mittel (bei sehr langen Namen ggf. Auto-Kürzung)
    String street = streetName;
    // Simple Kürzung falls zu breit: (optional verfeinern)
    int16_t bx, by; uint16_t bw, bh;
    u8g2.getUTF8Width(street.c_str()); // Warmup
    while (street.length() > 3) {
      u8g2.setFont(u8g2_font_helvB18_tf);
      uint16_t w = u8g2.getUTF8Width(street.c_str());
      if (textX + (int)w < (int)display.width() - 6) break;
      street.remove(street.length() - 1);
      street += "...";
      if (street.endsWith("......")) { street = streetName.substring(0, 10) + "..."; break; }
    }

    setFontMedium();
    u8g2.setCursor(textX, baseline + 28 + 28);
    u8g2.print(street);

    // Richtung klein
    setFontSmall();
    u8g2.setCursor(textX, baseline + 28 + 28 + 22);
    u8g2.print("Richtung ");
    u8g2.print(directionText);

    // Optional: feine Bodenlinie
    // display.drawLine(0, display.height() - 1, display.width(), display.height() - 1, GxEPD_BLACK);

  } while (display.nextPage());
}

// ---------- DEMO: Beispielanweisung ----------
void showDemo() {
  // Beispiel: Geradeaus in 113 m, Straße "Mülitobelstrasse", Richtung Norden
  renderNavCompact("113 m", "Mülitobelstrasse", "Norden", "STRAIGHT", /*raFrame*/1, /*iconScale*/2);
  // Für Kreisverkehr-Animation könntest du nacheinander raFrame 1..9 rendern.
}

// ---------- SETUP ----------
void setup() {
  // Serial optional
  // Serial.begin(115200);

  // E-Paper init
  display.init(115200); // SPI + EPD init (Baudrate ggf. anpassen)

  // U8g2-Bridge für UTF-8 starten
  u8g2.begin(display);
  u8g2.setFontMode(1);                       // transparent
  u8g2.setForegroundColor(GxEPD_BLACK);
  u8g2.setBackgroundColor(GxEPD_WHITE);

  // DEMO zeigen (du rufst später renderNavCompact(...) mit echten Daten)
  showDemo();
}

// ---------- LOOP ----------
void loop() {
  // Hier würdest du neue Navigationsdaten verarbeiten
  // und renderNavCompact(...) erneut aufrufen (Partial Updates optional).
  // Für E-Paper eher ereignisgetrieben als schnell wiederholen.
}

ChatGPT:

Nachgedacht für 10s
alles klar — wir springen genau auf diese „funktionierende“ Basis zurück und ich gebe dir das komplette .ino in einem Stück. Lass deinen Bitmap-Tab unverändert drin (so wie du ihn vorher hattest). Wichtig ist nur, dass die Symbolnamen exakt gleich heißen (die extern-Deklarationen unten beziehen sich darauf).

Kopier das hier 1:1 in deine Display_Graphisch_v2.ino (oder eine neue .ino) und lass den Bitmap-Tab im selben Sketch-Ordner geöffnet:

// =======================
//  Navi-Display (kompakt)
//  - UTF-8 mit U8g2-Fonts (Umlaute ok)
//  - Großes, skaliertes Piktogramm
//  - Distanz / Straße / Richtung als Block (kein Fließtext)
// =======================

#include <Arduino.h>
#include <SPI.h>
#include <GxEPD2_BW.h>                 // E-Paper
#include <U8g2_for_Adafruit_GFX.h>     // UTF-8 Fonts

// ---------- DISPLAY (PINS & PANEL) ----------
// PINS ggf. an dein Board anpassen:
#define EPD_CS   5     // Chip Select
#define EPD_DC   17    // Data/Command
#define EPD_RST  16    // Reset (oder -1, wenn fest verdrahtet)
#define EPD_BUSY 4     // Busy

// Wähle hier dein Panel (Beispiel: 2.9" b/w 296x128, GDEH029A1):
// -> Wenn du ein anderes Display hast, NUR diese Zeile anpassen:
GxEPD2_BW<GxEPD2_290, GxEPD2_290::HEIGHT> display(GxEPD2_290(EPD_CS, EPD_DC, EPD_RST, EPD_BUSY));

// ---------- BITMAPS (separater Tab) ----------
// Wenn du deinen Bitmap-Tab bereits hast, brauchst du HIER nichts zu tun.
// (hier einfügen)  <-- NICHTS einfügen, wir verwenden den separaten Tab.

// Referenzen zu den Bitmaps (müssen exakt so im Bitmap-Tab existieren):
extern const unsigned char epd_bitmap_Pfeil_geradeaus[];
extern const unsigned char epd_bitmap_Pfeil_links_abbiegen[];
extern const unsigned char epd_bitmap_Pfeil_links_einspuren[];
extern const unsigned char epd_bitmap_Pfeil_rechts_abbiegen[];
extern const unsigned char epd_bitmap_Pfeil_rechts_einspuren[];
extern const unsigned char epd_bitmap_Kreisverkehr2_1[];
extern const unsigned char epd_bitmap_Kreisverkehr2_2[];
extern const unsigned char epd_bitmap_Kreisverkehr2_3[];
extern const unsigned char epd_bitmap_Kreisverkehr2_4[];
extern const unsigned char epd_bitmap_Kreisverkehr2_5[];
extern const unsigned char epd_bitmap_Kreisverkehr2_6[];
extern const unsigned char epd_bitmap_Kreisverkehr2_7[];
extern const unsigned char epd_bitmap_Kreisverkehr2_8[];
extern const unsigned char epd_bitmap_Kreisverkehr2_9[];

// ---------- UTF-8 Fonts Bridge ----------
U8G2_FOR_ADAFRUIT_GFX u8g2;

// ---------- Utility: 1bpp Bitmap skaliert zeichnen ----------
static void drawBitmapScaled1bpp(
  int16_t x, int16_t y,
  const uint8_t* bmpPROGMEM,
  uint16_t w, uint16_t h,
  uint8_t scale,
  uint16_t color
) {
  const uint16_t rowBytes = (w + 7) / 8;
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint16_t byteIndex = yy * rowBytes + (xx >> 3);
      uint8_t  bitMask   = 0x80 >> (xx & 7);
      uint8_t  b         = pgm_read_byte(bmpPROGMEM + byteIndex);
      if (b & bitMask) {
        display.fillRect(x + xx * scale, y + yy * scale, scale, scale, color);
      }
    }
  }
}

// ---------- Fonts schnell wechseln ----------
inline void setFontLarge()  { u8g2.setFont(u8g2_font_helvB24_tf); }  // Distanz
inline void setFontMedium() { u8g2.setFont(u8g2_font_helvB18_tf); }  // Straßenname
inline void setFontSmall()  { u8g2.setFont(u8g2_font_helvR14_tf); }  // Richtung

// ---------- Icon-Auswahl ----------
const unsigned char* iconFromCode(const String& code, uint8_t frame = 1) {
  // code: "STRAIGHT", "LEFT", "RIGHT", "MERGE_L", "MERGE_R", "RA" (Kreisverkehr)
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;

  // Kreisverkehr animierbar: frame 1..9
  if (code == "RA") {
    switch (frame) {
      case 1:  return epd_bitmap_Kreisverkehr2_1;
      case 2:  return epd_bitmap_Kreisverkehr2_2;
      case 3:  return epd_bitmap_Kreisverkehr2_3;
      case 4:  return epd_bitmap_Kreisverkehr2_4;
      case 5:  return epd_bitmap_Kreisverkehr2_5;
      case 6:  return epd_bitmap_Kreisverkehr2_6;
      case 7:  return epd_bitmap_Kreisverkehr2_7;
      case 8:  return epd_bitmap_Kreisverkehr2_8;
      case 9:  return epd_bitmap_Kreisverkehr2_9;
      default: return epd_bitmap_Kreisverkehr2_1;
    }
  }
  // Fallback
  return epd_bitmap_Pfeil_geradeaus;
}

// ---------- Layoutrender: kompaktes Navi ----------
// Zeigt: großes Icon + Distanz (groß) + Straße (mittel) + "Richtung X" (klein)
void renderNavCompact(
  const String& distanceMeters,    // z.B. "113 m"
  const String& streetName,        // z.B. "Mülitobelstrasse"
  const String& directionText,     // z.B. "Norden"
  const String& iconCode,          // z.B. "STRAIGHT", "LEFT", "RIGHT", "MERGE_R", "RA"
  uint8_t raFrame = 1,             // Kreisverkehr-Frame 1..9 (für Animation)
  uint8_t iconScale = 2            // 2 = 128×128 aus 64×64; 3 = 192×192
) {
  display.setFullWindow();                 
  display.firstPage();
  do {
    display.fillScreen(GxEPD_WHITE);

    // --- Icon links groß ---
    const uint16_t ICON_W = 64, ICON_H = 64;
    const int16_t  iconX  = 8;
    const int16_t  iconY  = 8;
    const unsigned char* icon = iconFromCode(iconCode, raFrame);
    drawBitmapScaled1bpp(iconX, iconY, icon, ICON_W, ICON_H, iconScale, GxEPD_BLACK);

    // --- Text rechts daneben ---
    const int16_t textX = iconX + ICON_W * iconScale + 12;
    int16_t baseline = iconY + 6;

    // Distanz groß
    setFontLarge();
    u8g2.setCursor(textX, baseline + 28);
    u8g2.print(distanceMeters);

    // Straße medium mit einfacher Kürzung wenn zu breit
    String street = streetName;
    while (street.length() > 3) {
      u8g2.setFont(u8g2_font_helvB18_tf);
      uint16_t w = u8g2.getUTF8Width(street.c_str());
      if (textX + (int)w < (int)display.width() - 6) break;
      street.remove(street.length() - 1);
      if (!street.endsWith("...")) street += "...";
      if (street.length() > 20) { street = streetName.substring(0, 17) + "..."; break; }
    }

    setFontMedium();
    u8g2.setCursor(textX, baseline + 28 + 28);
    u8g2.print(street);

    // Richtung klein
    setFontSmall();
    u8g2.setCursor(textX, baseline + 28 + 28 + 22);
    u8g2.print("Richtung ");
    u8g2.print(directionText);

  } while (display.nextPage());
}

// ---------- DEMO ----------
void showDemo() {
  // Beispiel: Geradeaus in 113 m, Straße "Mülitobelstrasse", Richtung Norden
  renderNavCompact("113 m", "Mülitobelstrasse", "Norden", "STRAIGHT", /*raFrame*/1, /*iconScale*/2);
  // Für Kreisverkehr-Animation: raFrame 1..9 nacheinander rendern.
}

// ---------- SETUP ----------
void setup() {
  // Serial optional
  // Serial.begin(115200);

  // E-Paper init
  display.init(115200); // SPI + EPD init (Baudrate ggf. anpassen)

  // U8g2-Bridge für UTF-8 starten
  u8g2.begin(display);
  u8g2.setFontMode(1);                       // transparent
  u8g2.setForegroundColor(GxEPD_BLACK);
  u8g2.setBackgroundColor(GxEPD_WHITE);

  // DEMO zeigen (später mit echten Daten ersetzen)
  showDemo();
}

// ---------- LOOP ----------
void loop() {
  // Hier würdest du neue Navigationsdaten verarbeiten
  // und renderNavCompact(...) erneut aufrufen (Partial Updates optional).
}
kurzer check:

Dein Bitmap-Tab (der große mit epd_bitmap_...) muss im gleichen Sketch-Ordner liegen und in der IDE geöffnet sein, damit er mitkompiliert wird.

Die Namen der Bitmaps müssen exakt mit den extern-Zeilen übereinstimmen (tun sie bei dir).

Falls du ein anderes E-Paper-Panel hast, ändere nur die eine Zeile mit GxEPD2_290(...) auf deinen Typ (siehe Beispiele der GxEPD2-Library).

U8g2-Fonts sind bereits gesetzt; Umlaute funktionieren hier ohne Umschreibung.

Wenn’s damit immer noch hakt, sag mir bitte kurz: Board/MCU (UNO, ESP32, …), dein exaktes Panel (Waveshare-Bezeichnung) und welche Fehlermeldung jetzt kommt — dann passe ich die eine Zeile für das Panel bzw. die Pins passend an.

Du:
das war der Code, bei dem noch alles funkioniert hat, der von vorher hat auch nicht funktioniert:
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine Bitmaps & Array-Namen

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_SIZE = 64;   // 64x64 px Symbole
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

void sanitize(String &s) {
  // UTF-8 BOM + Steuerzeichen entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) {
    s.remove(0, 1);
  }
  s.replace("\r", "");
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// sehr einfache Text-Umbruchausgabe (Adafruit-GFX Font)
void printWrapped(int x, int y, int w, const String &s, uint8_t textSize, uint16_t color) {
  tft.setTextSize(textSize);
  tft.setTextColor(color, BLACK);
  const int charW = 6 * textSize;
  const int charH = 8 * textSize + 2;
  int maxChars = max(1, w / charW);

  int i = 0;
  while (i < (int)s.length()) {
    int lineEnd = min(i + maxChars, (int)s.length());
    int space = -1;
    for (int j = i; j < lineEnd; j++) if (s[j] == ' ') space = j;
    int cut = (lineEnd == (int)s.length()) ? (int)s.length() : (space >= i ? space : lineEnd);
    String line = s.substring(i, cut);
    tft.setCursor(x, y);
    tft.print(line);
    y += charH;
    i = (space >= i && lineEnd != (int)s.length()) ? space + 1 : cut;
    if (y > SCREEN_H - charH - 4) break;
  }
}

// Icon anhand Code zurückgeben
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // "CODE|TEXT" oder nur "TEXT"
  int sep = line.indexOf('|');
  String code, text;
  if (sep >= 0) {
    code = line.substring(0, sep);
    text = line.substring(sep + 1);
  } else {
    text = line;
  }

  // Icon anzeigen (links)
  const uint8_t* bmp = iconFromCode(code);
  int textX = MARGIN_X, textY = HEADER_H + 10;
  if (bmp) {
    // drawBitmap kann PROGMEM 1-bit bitmaps
    tft.drawBitmap(MARGIN_X, HEADER_H + 10, bmp, ICON_SIZE, ICON_SIZE, WHITE);
    textX = ICON_SIZE + 2*MARGIN_X;         // Text rechts daneben
    textY = HEADER_H + 12;
  }

  // Text
  int availW = SCREEN_W - textX - MARGIN_X;
  printWrapped(textX, textY, availW, text, 2, WHITE);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}

das Problem war ja dann die Darstellung (Piktogramm zu klein, zu viel Text und Probleme mit den Umlauten). Kannst du nochmals versuchen dies zu verbesseren? Gib mir gleich den gesamten Code den du auf Basis des obigen Code machst
ChatGPT:

Nachgedacht für 25s
super, wir bleiben bei MCUFRIEND_kbv + Adafruit_GFX und verbessern genau deine drei Punkte – ohne neue Libraries:

Piktogramm skalieren (1×, 1.5×, 2×; standardmäßig 2× → 128×128)

Kein Fließtext mehr, sondern Distanz / Straße / Richtung getrennt

Umlaute robust: da Adafruit_GFX keine UTF-8 kann, ersetze ich automatisch
ä→ae, ö→oe, ü→ue, Ä→Ae, Ö→Oe, Ü→Ue, ß→ss (lesbar & sicher)

Der Sketch versteht weiterhin dein altes Format CODE|TEXT. Er versucht aus dem Text
„In 113m auf Mülitobelstrasse Richtung Norden fahren.“ automatisch
Distanz = 113 m, Straße = Mülitobelstrasse, Richtung = Norden zu ziehen.
Optional kannst du künftig auch direkt strukturiert schicken:
CODE|113 m|Mülitobelstrasse|Norden.

Hier der vollständige Code (ersetzt deinen bisherigen .ino).
Deinen bitmaps.h lässt du unverändert drin.

#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine Bitmaps & Array-Namen (64x64, 1-bit)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße 64x64
const float ICON_SCALE = 2.0f;     // 1.0 = 64px, 1.5 = 96px, 2.0 = 128px
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

// UTF-8 BOM + Steuerzeichen entfernen
void sanitize(String &s) {
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// UTF-8 Umlaute in ASCII-ersetzungen (Adafruit_GFX hat keine UTF-8)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  int idx;
  while ((idx = s.indexOf(u8)) >= 0) {
    s.remove(idx, strlen(u8));
    s.insert(idx, ascii);
  }
}
void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// sehr einfache Ellipsen-Kürzung auf Breite in Pixel (feste 5x7-Font Logik)
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;  // Adafruit 5x7 Font mit 1px spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (weiß auf schwarz)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);              // nur 1×,2×,3× sinnvoll; runden
  if (s < 1) s = 1;
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code zurückgeben
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// -------- Parsing der Anweisung in Distanz/Straße/Richtung --------
struct NavData {
  String code;
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse" (Umlaute bereits ersetzt)
  String direction;  // "Norden"
};

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

// heuristische Extraktion aus Fließtext
void parseFreeText(const String &text, NavData &out) {
  String t = text;
  // Distanz (erste Zahl + optional m)
  int iNum = -1; for (int i=0;i<(int)t.length();i++){ if (isDigit(t[i])) { iNum=i; break; } }
  if (iNum >= 0) {
    int j=iNum; while (j<(int)t.length() && (isDigit(t[j])||t[j]==' ')) j++;
    // ggf. „m“ anhängen falls vorhanden
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) { j++; out.distance = num + " m"; }
    else out.distance = num + " m";
  }

  // Straße zwischen "auf " und " Richtung"
  int iAuf = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }

  // Richtung nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }
  // Fallbacks
  if (out.street.length()==0) out.street = " ";      // leer lassen ist ok
  if (out.direction.length()==0) out.direction = ""; // Optional
  if (out.distance.length()==0) out.distance = "";   // Optional
}

// Hauptparser für Zeile
NavData parseInstruction(const String &line) {
  NavData nd;
  // Unterstützt:
  // 1) CODE|FREITEXT
  // 2) CODE|DISTANZ|STRASSE|RICHTUNG
  // 3) nur FREITEXT
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      // strukturiert
      int p3 = rest.indexOf('|', p2 + 1);
      nd.distance = rest.substring(0, p2);          nd.distance.trim();
      if (p3 >= 0) {
        nd.street   = rest.substring(p2+1, p3);     nd.street.trim();
        nd.direction= rest.substring(p3+1);         nd.direction.trim();
      } else {
        // CODE|TEXT (doch nur 2-teilig)
        parseFreeText(rest, nd);
      }
    } else {
      // CODE|TEXT
      parseFreeText(rest, nd);
    }
  } else {
    // nur TEXT
    parseFreeText(line, nd);
  }
  // Umlaute ersetzen
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// ---------------- Darstellung ----------------

// kompaktes Layout: großes Icon links, rechts Distanz/Strasse/Richtung
void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);
  int iconH = iconW;

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;   // Text rechts neben Icon
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3); // groß
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10; // Zeilenhöhe + Abstand
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel/klein)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

// ---------------- Oberflächen-API wie bisher ----------------
void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  NavData nd = parseInstruction(line);
  showCompact(nd);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}
so nutzt du’s
Alte Sätze funktionieren weiter:
STRAIGHT|In 113m auf Mülitobelstrasse Richtung Norden fahren.
→ großes Geradeaus-Icon (128×128), rechts: 113 m, Muelitobelstrasse, Richtung Norden.

Oder strukturiert (empfohlen):
STRAIGHT|113 m|Mülitobelstrasse|Norden

Wenn du das Icon noch größer/kleiner möchtest, passe ICON_SCALE oben an (1.5f oder 2.0f).

Du:
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino: In function 'void replaceUTF8(String&, const char*, const char*)':
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:42:7: error: 'class String' has no member named 'insert'; did you mean 'init'?
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino: In function 'const uint8_t* iconFromCode(const String&)':
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:93:7: error: 'c' was not declared in this scope
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:93:7: error: expected ')' at end of input
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:93:7: error: expected statement at end of input
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:93:7: error: expected '}' at end of input
exit status 1

Compilation error: 'class String' has no member named 'insert'; did you mean 'init'?
ChatGPT:

Nachgedacht für 21s
Danke fürs Log — ich hab’s gefixt. Problem 1 war String.insert() (gibt’s auf Arduino nicht). Ich ersetze die UTF-8-Umlaute jetzt über indexOf(...) + substring(...). Außerdem habe ich den Sketch einmal komplett sauber zusammengestellt.

Kopier das komplett über dein aktuelles .ino. bitmaps.h bleibt wie bei dir.

#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße 64x64
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

void sanitize(String &s) {
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3); // UTF-8 BOM
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// UTF-8-Umlaute → ASCII (weil Adafruit_GFX kein UTF-8 kann)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    idx = s.indexOf(pat, left.length() + strlen(ascii)); // weitersuchen hinter Einfügung
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// in Pixel begrenzen, mit "..."
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;                    // 5x7 Font + 1 Spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (integer scaling: 1x,2x,3x)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);  // 1, 2, 3 ...
  if (s < 1) s = 1;
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// -------- Parsing in Distanz/Straße/Richtung --------
struct NavData {
  String code;
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse"
  String direction;  // "Norden"
};

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

void parseFreeText(const String &text, NavData &out) {
  String t = text;
  // Distanz: erste Zahl (+ evtl. m)
  int iNum = -1; for (int i=0;i<(int)t.length();i++){ if (isDigit(t[i])) { iNum=i; break; } }
  if (iNum >= 0) {
    int j=iNum; while (j<(int)t.length() && (isDigit(t[j])||t[j]==' ')) j++;
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) { j++; out.distance = num + " m"; }
    else out.distance = num + " m";
  }
  // Straße: zwischen "auf " und " Richtung"
  int iAuf = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }
  // Richtung: nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }
  if (out.street.length()==0) out.street = " ";
  if (out.direction.length()==0) out.direction = "";
  if (out.distance.length()==0) out.distance = "";
}

NavData parseInstruction(const String &line) {
  NavData nd;
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      int p3 = rest.indexOf('|', p2 + 1);
      nd.distance = rest.substring(0, p2);          nd.distance.trim();
      if (p3 >= 0) {
        nd.street    = rest.substring(p2+1, p3);    nd.street.trim();
        nd.direction = rest.substring(p3+1);        nd.direction.trim();
      } else {
        parseFreeText(rest, nd);
      }
    } else {
      parseFreeText(rest, nd);
    }
  } else {
    parseFreeText(line, nd);
  }
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// ---------------- Darstellung ----------------

void showCompact(const NavData &nd) {
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);
  int iconH = iconW;

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10;
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

// ---------------- API wie bisher ----------------
void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  NavData nd = parseInstruction(line);
  showCompact(nd);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}
Hinweise:

Icon-Größe per ICON_SCALE anpassen (1.5f oder 2.0f).

Strukturierte Eingabe geht auch: STRAIGHT|113 m|Mülitobelstrasse|Norden.

Falls du statt ASCII-Ersatz echte Umlaute willst, bräuchten wir eine GFX-Font mit Glyphen oder U8g2-Bridge; das würde aber die Lib-Lage ändern.

Du:
gib mir wie zuvor gleich wieder das ganze aktualisierte Skript:
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:125:40: error: 'NavData' has not been declared
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:158:1: error: 'NavData' does not name a type
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:188:24: error: 'NavData' does not name a type
exit status 1

Compilation error: 'NavData' has not been declared
ChatGPT:

Nachgedacht für 21s
alles klar — hier ist das vollständige, bereinigte Skript auf Basis deines funktionierenden TFT-Codes, mit:

größeren Piktogrammen (skalierbar),

blockweiser Darstellung: Distanz (groß) / Straße (mittel) / Richtung (mittel),

robuster Umlaut-Ersatz (UTF-8 → ASCII), damit Adafruit_GFX sauber zeichnet.

Kopier das komplett in deine Display_Graphisch_v1.ino.
bitmaps.h bleibt dein vorhandenes File.

#include <Arduino.h>
#include <string.h>
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße deiner Bitmaps (64x64)
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px (Empfehlung: 1.5–2.0)
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ---------------- Hilfsfunktionen ----------------

void sanitize(String &s) {
  // UTF-8 BOM entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  // Steuerzeichen & CR raus
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// UTF-8-Umlaute → ASCII (weil Adafruit_GFX kein UTF-8 kann)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    // hinter dem soeben eingefügten Text weiter suchen
    idx = s.indexOf(pat, left.length() + strlen(ascii));
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// in Pixel begrenzen, mit "..."
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;                 // 5x7 Font + 1 Spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (1x,2x,3x …)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);
  if (s < 1) s = 1;

  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// -------- Datenstruktur & Parsing --------
struct NavData {
  String code;
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse" (umlautfix)
  String direction;  // "Norden"
};

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

void parseFreeText(const String &text, NavData &out) {
  String t = text;

  // Distanz: erste Zahl (+ optional 'm')
  int iNum = -1;
  for (int i = 0; i < (int)t.length(); i++) {
    if (isDigit(t[i])) { iNum = i; break; }
  }
  if (iNum >= 0) {
    int j = iNum;
    while (j < (int)t.length() && (isDigit(t[j]) || t[j]==' ')) j++;
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) j++;
    out.distance = num + " m";
  }

  // Straße: zwischen "auf " und " Richtung"
  int iAuf   = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }

  // Richtung: nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }

  if (out.street.length()==0)    out.street = " ";
  if (out.direction.length()==0) out.direction = "";
  if (out.distance.length()==0)  out.distance = "";
}

NavData parseInstruction(const String &line) {
  NavData nd;
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      int p3 = rest.indexOf('|', p2 + 1);
      nd.distance = rest.substring(0, p2);          nd.distance.trim();
      if (p3 >= 0) {
        nd.street    = rest.substring(p2+1, p3);    nd.street.trim();
        nd.direction = rest.substring(p3+1);        nd.direction.trim();
      } else {
        parseFreeText(rest, nd);
      }
    } else {
      parseFreeText(rest, nd);
    }
  } else {
    parseFreeText(line, nd);
  }
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// ---------------- Darstellung ----------------

void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);
  // int iconH = iconW; // quadratisch, falls benötigt

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10;
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

// ---------------- API wie bisher ----------------
void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  NavData nd = parseInstruction(line);
  showCompact(nd);
}

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}
Tipps:

Piktogrammgröße über ICON_SCALE ändern (z. B. 1.5f oder 2.0f).

Strukturierte Eingabe klappt weiterhin:
STRAIGHT|113 m|Mülitobelstrasse|Norden

Freitext wie
In 113m auf Mülitobelstrasse Richtung Norden fahren.
wird geparst in Distanz/Straße/Richtung und kompakt angezeigt.

Du:
irgendetwas ist immernoch falsch:
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:131:40: error: 'NavData' has not been declared
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:172:1: error: 'NavData' does not name a type
C:\Users\simir\OneDrive - kszi.ch\1_Maturitätsarbeit\3_Prozess\Valhalla_Display\Display_Graphisch_v1\Display_Graphisch_v1.ino:202:24: error: 'NavData' does not name a type
exit status 1

Compilation error: 'NavData' has not been declared
ChatGPT:

Nachgedacht für 12s
Hier ist das vollständige, korrigierte Skript (mit größerem Piktogramm, kompaktem Layout und Umlaut-Fix).
Einfach komplett in Display_Graphisch_v1.ino einfügen. Dein bitmaps.h bleibt wie gehabt.

#include <Arduino.h>
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße deiner Bitmaps (64x64)
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ===================== Datenstruktur =====================
struct NavData {
  String code;       // "STRAIGHT", "LEFT", ...
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse" (mit Umlaut-Ersatz)
  String direction;  // "Norden"
};

// ===================== Hilfsfunktionen ===================

void sanitize(String &s) {
  // UTF-8 BOM entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  // Steuerzeichen & CR raus
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// UTF-8-Umlaute → ASCII (weil Adafruit_GFX kein UTF-8 kann)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    idx = s.indexOf(pat, left.length() + strlen(ascii));
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// in Pixel begrenzen, mit "..."
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;                 // 5x7 Font + 1 Spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (1x,2x,3x …)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);
  if (s < 1) s = 1;

  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// ===================== Parsing =====================

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

void parseFreeText(const String &text, NavData &out) {
  String t = text;

  // Distanz: erste Zahl (+ optional 'm')
  int iNum = -1;
  for (int i = 0; i < (int)t.length(); i++) {
    if (isDigit(t[i])) { iNum = i; break; }
  }
  if (iNum >= 0) {
    int j = iNum;
    while (j < (int)t.length() && (isDigit(t[j]) || t[j]==' ')) j++;
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) j++;
    out.distance = num + " m";
  }

  // Straße: zwischen "auf " und " Richtung"
  int iAuf   = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }

  // Richtung: nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }

  if (out.street.length()==0)    out.street = " ";
  if (out.direction.length()==0) out.direction = "";
  if (out.distance.length()==0)  out.distance = "";
}

NavData parseInstruction(const String &line) {
  NavData nd;
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      int p3 = rest.indexOf('|', p2 + 1);
      nd.distance = rest.substring(0, p2);          nd.distance.trim();
      if (p3 >= 0) {
        nd.street    = rest.substring(p2+1, p3);    nd.street.trim();
        nd.direction = rest.substring(p3+1);        nd.direction.trim();
      } else {
        parseFreeText(rest, nd);
      }
    } else {
      parseFreeText(rest, nd);
    }
  } else {
    parseFreeText(line, nd);
  }
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// ===================== Darstellung =====================

void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10;
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

// ===================== API wie bisher =====================

void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  NavData nd = parseInstruction(line);
  showCompact(nd);
}

// ===================== Setup / Loop =====================

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}
Hinweise:

Piktogrammgröße über ICON_SCALE (z. B. 1.5f oder 2.0f) einstellen.

Strukturierte Eingabe funktioniert: STRAIGHT|113 m|Mülitobelstrasse|Norden

Freitext wie In 113m auf Mülitobelstrasse Richtung Norden fahren. wird automatisch zerlegt und kompakt dargestellt.

Du:
hast du die "Kein GPS Signal" Meldung entfernt?
ChatGPT:

Nachgedacht für 22s
Ja — in der aktuellen Version habe ich die Meldung „Kein GPS Signal“ entfernt und nur den Starttext „Warte auf Anweisung…“ gelassen.

Wenn du die Meldung wieder willst, hier die kleine Ergänzung (nur einfügen, Rest bleibt wie im letzten Skript):

Ganz oben (bei den Globals) hinzufügen:

unsigned long lastRx = 0;
const unsigned long NO_GPS_MS = 5000;   // nach 5 s ohne Daten
bool noGpsShown = false;
Nach drawHeader() in setup():

lastRx = millis();
Hilfsfunktion ins File (z. B. unter showCompact(...)):

void showNoGPS() {
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.setCursor(20, HEADER_H + 40);
  tft.print("Kein GPS Signal");
}
loop() anpassen:

void loop() {
  bool got = false;

  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
      got = true;
    }
  }

  if (got) {
    lastRx = millis();
    noGpsShown = false;   // wieder ausblenden, sobald Daten kommen
  } else if ((millis() - lastRx > NO_GPS_MS) && !noGpsShown) {
    showNoGPS();
    noGpsShown = true;
  }
}
Damit erscheint automatisch „Kein GPS Signal“, wenn für >5 s keine neuen Daten eintreffen, und verschwindet wieder, sobald etwas ankommt.

Du:
kannst du mir gerade den gesamten Code geben? Also derselbe wie vorhin, aber nun wieder mit der kein GPS Meldung
ChatGPT:

Nachgedacht für 37s
Hier ist das volle, lauffähige Skript für dein MCUFRIEND-TFT – mit:

großem (skaliertem) Piktogramm,

kompaktem Layout (Distanz / Straße / Richtung),

einfacher Umlaut-/UTF-8-Ersetzung,

automatischer „Kein GPS Signal“-Meldung nach 5 s ohne Daten,

Rückwärtskompatibilität: versteht sowohl CODE|TEXT (alt) als auch CODE|DIST|STREET|DIR (neu).

Wichtig: Lass deine bitmaps.h (mit den 64×64-Symbolen) unverändert im Projekt.

#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include <Arduino.h>
#include <avr/pgmspace.h>
#include "bitmaps.h"   // enthält deine 64x64 1bpp Bitmaps (PROGMEM)

// ---------------- Display / Layout ----------------
MCUFRIEND_kbv tft;

#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

const int SCREEN_W   = 320;
const int SCREEN_H   = 240;
const int HEADER_H   = 30;
const int MARGIN_X   = 12;

const int ICON_W     = 64;
const int ICON_H     = 64;
const int ICON_SCALE = 2;        // 2 => 128x128 aus 64x64

const long BAUD      = 115200;

// ---------------- Status / GPS-Timeout ----------------
String lastLine = "";
unsigned long lastRx = 0;
const unsigned long NO_GPS_MS = 5000;   // 5 s ohne Daten -> "Kein GPS Signal"
bool noGpsShown = false;

// ---------------- Hilfsfunktionen ----------------

// BOM/Steuerzeichen entfernen
void sanitize(String &s) {
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// einfache UTF-8 → ASCII Ersetzung (für Adafruit_GFX Default-Font)
void replaceUTF8(String &s, const char *u8, const char *ascii) { s.replace(u8, ascii); }

void normalizeText(String &s) {
  sanitize(s);
  // Umlaute / ß
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
  // Akzente (einfach)
  replaceUTF8(s, "\xC3\xA9", "e");  // é
  replaceUTF8(s, "\xC3\xA8", "e");  // è
  replaceUTF8(s, "\xC3\xA0", "a");  // à
  replaceUTF8(s, "\xC3\xA2", "a");  // â
  replaceUTF8(s, "\xC3\xAA", "e");  // ê
  replaceUTF8(s, "\xC3\xA7", "c");  // ç
  // Zeichen
  replaceUTF8(s, "\xC2\xB0", " deg");   // °
  replaceUTF8(s, "\xE2\x80\x93", "-");  // –
  replaceUTF8(s, "\xE2\x80\x94", "-");  // —
}

// Header-Zeile
void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// Einfaches Wortwrap für Fallback/Legacy-Text
void printWrapped(int x, int y, int w, const String &s, uint8_t textSize, uint16_t color) {
  tft.setTextSize(textSize);
  tft.setTextColor(color, BLACK);
  const int charW = 6 * textSize;
  const int charH = 8 * textSize + 2;
  int maxChars = max(1, w / charW);

  int i = 0;
  while (i < (int)s.length()) {
    int lineEnd = min(i + maxChars, (int)s.length());
    int space = -1;
    for (int j = i; j < lineEnd; j++) if (s[j] == ' ') space = j;
    int cut = (lineEnd == (int)s.length()) ? (int)s.length() : (space >= i ? space : lineEnd);
    String line = s.substring(i, cut);
    tft.setCursor(x, y);
    tft.print(line);
    y += charH;
    i = (space >= i && lineEnd != (int)s.length()) ? space + 1 : cut;
    if (y > SCREEN_H - charH - 4) break;
  }
}

// PROGMEM 1bpp Bitmap skaliert zeichnen
void drawBitmapScaled1bpp(int16_t x, int16_t y,
                          const uint8_t* bmpPROGMEM,
                          uint16_t w, uint16_t h,
                          uint8_t scale, uint16_t color) {
  const uint16_t rowBytes = (w + 7) / 8;
  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint16_t byteIndex = yy * rowBytes + (xx >> 3);
      uint8_t  bitMask   = 0x80 >> (xx & 7);
      uint8_t  b         = pgm_read_byte(bmpPROGMEM + byteIndex);
      if (b & bitMask) {
        tft.fillRect(x + xx * scale, y + yy * scale, scale, scale, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// Text auf verfügbare Breite kürzen (mit „...“)
String ellipsizeToWidth(String s, int maxPixelW, uint8_t textSize) {
  normalizeText(s);
  const int charW = 6 * textSize;
  int maxChars = max(1, maxPixelW / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return s.substring(0, max(0, maxChars));
  return s.substring(0, maxChars - 3) + "...";
}

// Kompakte Navi-Anzeige
void showCompact(String distance, String street, String direction, const String &code) {
  normalizeText(distance);
  normalizeText(street);
  normalizeText(direction);

  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon links groß
  const uint8_t* bmp = iconFromCode(code);
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_W, ICON_H, ICON_SCALE, WHITE);
  }

  // Text rechts daneben
  int textX = bmp ? (iconX + ICON_W * ICON_SCALE + 12) : MARGIN_X;
  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz groß
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(3);
  tft.setCursor(textX, HEADER_H + 24);
  tft.print(ellipsizeToWidth(distance, availW, 3));

  // Straße mittel
  tft.setTextSize(2);
  tft.setCursor(textX, HEADER_H + 24 + 28);
  tft.print(ellipsizeToWidth(street, availW, 2));

  // Richtung („Richtung X“)
  tft.setTextSize(2);
  tft.setCursor(textX, HEADER_H + 24 + 28 + 22);
  String dirLine = "Richtung " + direction;
  tft.print(ellipsizeToWidth(dirLine, availW, 2));
}

// Fallback: alter Modus (ein Fließtext rechts neben Icon)
void showLegacy(const String &code, String text) {
  normalizeText(text);
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  const uint8_t* bmp = iconFromCode(code);
  int textX = MARGIN_X, textY = HEADER_H + 10;

  if (bmp) {
    drawBitmapScaled1bpp(MARGIN_X, HEADER_H + 8, bmp, ICON_W, ICON_H, ICON_SCALE, WHITE);
    textX = ICON_W * ICON_SCALE + 2 * MARGIN_X;
    textY = HEADER_H + 12;
  }

  int availW = SCREEN_W - textX - MARGIN_X;
  printWrapped(textX, textY, availW, text, 2, WHITE);
}

// Kein-GPS-Anzeige
void showNoGPS() {
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.setCursor(20, HEADER_H + 40);
  tft.print("Kein GPS Signal");
}

// Zeile verarbeiten:
// - Neu:  CODE|DIST|STREET|DIR
// - Alt:  CODE|TEXT
// - Nur TEXT → Fallback ohne Icon
void showInstruction(const String &lineRaw) {
  String line = lineRaw;
  if (line == lastLine) return;
  lastLine = line;

  int p1 = line.indexOf('|');
  if (p1 < 0) {
    // Nur Text
    showLegacy("", line);
    return;
  }

  String code = line.substring(0, p1);
  String rest = line.substring(p1 + 1);

  int p2 = rest.indexOf('|');
  if (p2 < 0) {
    // Alt: CODE|TEXT
    showLegacy(code, rest);
    return;
  }

  // Neu: wir erwarten noch einen dritten '|'
  String dist  = rest.substring(0, p2);
  String rest2 = rest.substring(p2 + 1);
  int p3 = rest2.indexOf('|');
  if (p3 < 0) {
    // doch Alt-Format
    showLegacy(code, rest);
    return;
  }

  String street = rest2.substring(0, p3);
  String dir    = rest2.substring(p3 + 1);

  showCompact(dist, street, dir, code);
}

// ---------------- Arduino Setup / Loop ----------------
void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();

  lastRx = millis();
}

void loop() {
  bool got = false;

  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
      got = true;
    }
  }

  if (got) {
    lastRx = millis();
    noGpsShown = false;   // wieder ausblenden, sobald Daten kommen
  } else if ((millis() - lastRx > NO_GPS_MS) && !noGpsShown) {
    showNoGPS();
    noGpsShown = true;
  }
}
Sendeformat (zur Erinnerung)
Neu/kompakt (empfohlen):

STRAIGHT|113 m|Mülitobelstrasse|Norden
LEFT|350 m|Dorfstrasse|Westen
RA3|40 m|Im Kreisel 3. Ausfahrt|Nordwest
Alt (weiter unterstützt):

RIGHT|In 120 m rechts abbiegen auf Hauptstrasse Richtung Süden.
Wenn du noch mehr Platz für Text brauchst, kannst du ICON_SCALE von 2 auf 1 setzen (dann 64×64). Umgekehrt: auf einem größeren Display ginge auch 3.

Du:
Jetzt habe ich folgendes Problem: ich fahre im Auto damit, als das GPS einen Fix hatte, kam die erste Anweisung, darauf eine zweite und danach passierte nichts mehr… hast du das Pi Skrip geändert, dass es nicht mehr weiter aktualisiert? Es ist einfach bei der gleichen Anweisung eingefroren
ChatGPT:

Nachgedacht für 1m 23s
Kurz: Ich habe an deinem Pi-Skript nichts geändert. Das Verhalten („2 Anweisungen, dann nix mehr“) passt sehr stark dazu, dass vom Pi keine neuen Zeilen mehr ankommen – oder immer genau derselbe String wiederholt wird (damit sieht es „eingefroren“ aus). Unser Arduino-Sketch zeigt „Kein GPS Signal“ nur, wenn gar nichts kommt; wenn der Pi weiter irgendwas sendet (auch gleiche Zeile), bleibt die letzte Anzeige stehen.

Fix – Pi-Skript so senden, dass es fortlaufend aktualisiert
Stelle sicher, dass der Pi wirklich regelmäßig neue Daten mit neuer Distanz schickt (neues Format: CODE|DIST|STREET|DIR) und jede Zeile mit \n endet und geflusht wird.

Minimal-Referenz (PySerial)
Teste damit zuerst unabhängig von deinem Navi-Code, ob das Display zuverlässig updatet:

# test_sender.py
import serial, time

PORT = "/dev/ttyACM0"  # ggf. /dev/ttyUSB0
BAUD = 115200

def open_port():
    return serial.Serial(PORT, BAUD, timeout=1, write_timeout=1)

ser = open_port()

def send(code, dist, street, direction):
    line = f"{code}|{dist}|{street}|{direction}\n"
    ser.write(line.encode("utf-8"))
    ser.flush()

dist = 500
try:
    while True:
        send("STRAIGHT", f"{dist} m", "Mülitobelstrasse", "Norden")
        dist = max(0, dist - 25)
        time.sleep(1)
except (serial.SerialException, OSError):
    # robuste Auto-Reconnect-Variante
    try:
        ser.close()
    except: pass
    time.sleep(1)
    ser = open_port()
Wenn damit die Distanz runterzählt, ist der Arduino-Teil OK – dann muss dein eigentlicher Navi-Sender genauso regelmäßig neue Distanzen liefern.

Typische Stolpersteine auf dem Pi
Kein Newline: ohne \n wartet der Arduino auf das Zeilenende → keine Updates.
✔ immer ... + "\n" senden und ser.flush() aufrufen.

Selber String: wenn dein Navi nur bei Manöverwechsel sendet, bleibt die Anzeige gleich.
✔ mindestens 1×/Sekunde Distanz neu senden (CODE, STREET, DIR dürfen gleich bleiben).

Port/Reset: Öffnen des Ports resettet viele Arduinos. Beim Reconnect ggf. 1–2 s warten, dann senden.
(Optional: stty -F /dev/ttyACM0 -hupcl, falls du beim Öffnen keinen Reset willst.)

Flow Control: keine XON/XOFF/RTS/CTS verwenden (Standard bei PySerial ist ok).

Buffer-Hänger: bei Exceptions Port schließen und neu öffnen (siehe Beispiel oben).

Optional: Mini-Tweaks am Arduino (falls du magst)
Wenn du möchtest, kann ich dir eine Variante schicken, die bei identischem String nach X Sekunden einen „live“-Zeitstempel rechts klein einblendet (damit du siehst, dass die Verbindung lebt), ändert aber am Kernproblem nichts: die Distanz muss vom Pi kommen.

Wenn du mir zeigst, wie dein Pi aktuell sendet (ein paar Beispielzeilen oder den Sende-Teil), passe ich dir das schnell so an, dass die Distanz im Sekundentakt aktualisiert wird.

Du:
wie genau muss ich diesen Code eingeben?
ChatGPT:

Nachgedacht für 22s
So machst du’s Schritt-für-Schritt auf dem Raspberry Pi 👇

1) Arduino anstecken & Port finden
ls -l /dev/serial/by-id/
Du bekommst einen „schönen“ Gerätenamen wie:

/dev/serial/by-id/usb-Arduino__www.arduino.cc__Arduino_Uno_75439303939351801131-if00
DIESEN String (oder ersatzweise /dev/ttyACM0 bzw. /dev/ttyUSB0) gleich im Script als PORT eintragen.

Falls „Permission denied“:
sudo usermod -aG dialout $USER → ab- und wieder anmelden (oder Pi neu starten).

2) Python & PySerial installieren
sudo apt update
sudo apt install -y python3 python3-pip
pip3 install --user pyserial
3) Test-Sender anlegen
nano test_sender.py
Inhalt einfügen (PORT anpassen!):

# test_sender.py
import serial, time, sys

# >>> HIER ANPASSEN: lieber den /dev/serial/by-id/... Pfad benutzen <<<
PORT = "/dev/ttyACM0"
BAUD = 115200

def open_port():
    # robust öffnen (kein HW-Flow, 8N1)
    return serial.Serial(PORT, BAUD, timeout=1, write_timeout=1)

def send_line(ser, code, dist, street, direction):
    # Arduino erwartet: CODE|DIST|STREET|DIR\n  (UTF-8)
    line = f"{code}|{dist}|{street}|{direction}\n"
    ser.write(line.encode("utf-8"))
    ser.flush()

def main():
    # Versuch: Port öffnen (mit Auto-Reconnect in der Loop)
    while True:
        try:
            with open_port() as ser:
                dist = 500
                while True:
                    send_line(ser, "STRAIGHT", f"{dist} m", "Mülitobelstrasse", "Norden")
                    dist = max(0, dist - 25)     # Distanz zählt runter
                    time.sleep(1)                # 1x pro Sekunde
        except Exception as e:
            print(f"[WARN] Serieller Fehler: {e}", file=sys.stderr)
            time.sleep(1)  # kurz warten und erneut versuchen

if __name__ == "__main__":
    main()
Speichern & schließen: Ctrl+O, Enter, Ctrl+X.

4) Script starten
python3 test_sender.py
Auf dem Display sollte nun:

der passende Pfeil erscheinen,

die Distanz jede Sekunde kleiner werden,

Straße und Richtung angezeigt werden.

Stoppen mit Ctrl+C.

Schnelltest ohne Python (optional)
Wenn du nur einmal eine Zeile schicken willst:

stty -F /dev/ttyACM0 115200 -echo -icanon
echo -e "STRAIGHT|113 m|Mülitobelstrasse|Norden" | iconv -t utf-8 > /dev/ttyACM0
Typische Stolpersteine
Permission denied: Benutzer zur Gruppe dialout hinzufügen (siehe oben) oder ausnahmsweise sudo python3 ….

Falscher Port: statt /dev/ttyACM0 den by-id-Pfad nutzen (stabiler).

Arduino reset beim Öffnen: ist normal; sende einfach ~1–2 Sek. später (das Script macht’s automatisch durch den Loop).

Keine Updates: Der Arduino updatet nur bei neuen Zeilen. Achte auf \n und ser.flush() (im Script schon drin).

Wenn das mit dem Test-Sender sauber läuft, lässt du in deinem „echten“ Pi-Skript einfach fortlaufend (z. B. jede Sekunde) neue Distanzen mit genau diesem Format raus – dann friert die Anzeige auch nicht mehr ein.

Du:
was genau hat dieses Programm gemacht?
ChatGPT:

Nachgedacht für 8s
Kurz gesagt: Es ist ein Test-Sender für den Arduino, kein Navi-Programm.

Was er konkret macht:

Öffnet den seriellen Port zum Arduino (115200 Baud). Wenn das Öffnen scheitert, versucht er es in einer Schleife erneut (Auto-Reconnect).

Schickt einmal pro Sekunde eine Zeile im Format
CODE|DIST|STREET|DIR\n
z. B. STRAIGHT|500 m|Mülitobelstrasse|Norden

Die Distanz zählt herunter (500 → 475 → 450 → … → 0).

Sendet als UTF-8, damit Umlaute korrekt beim Arduino ankommen.

Nutzt ser.flush(), damit jede Zeile wirklich rausgeht.

Macht sonst nichts: kein GPS, kein Internet, kein Einlesen von Daten – nur kontinuierlich Textzeilen zum Arduino schicken.

Zweck: End-to-End-Test deiner Anzeige‐Pipeline. Du siehst, ob:

das Display fortlaufend aktualisiert (also nicht “einfriert”),

die Pfeile zum CODE passen (z. B. STRAIGHT, LEFT, RIGHT, MERGE_L/R, RA1..RA9),

Umlaute korrekt sind,

und das Format stimmt.

Wenn das mit dem Test-Sender stabil läuft, kann dein echtes Pi-Navi-Script exakt dieses Format fortlaufend ausgeben – dann bleiben die Updates auf dem Display auch während der Fahrt nicht stehen.

Du:
das hat funktioniert, aber das alte Programm wird deshalb nicht plötzlich funktionieren. Entweder gab es ein Problem beim Arduino Skript oder beim Pi Skript. Soll ich dir nochmals die beiden Skripts schicken, dann kannst du die anschauen und den Fehler suchen
ChatGPT:

Nachgedacht für 27s
Ja, schick mir gern beide Skripte (Arduino .ino und Pi .py) – dann suche ich dir den Bug raus. Pack am besten noch 10–20 Zeilen der tatsächlichen Pi-Ausgabe dazu (was über Serial gesendet wird).

Bis dahin zwei schnelle, sehr wirkungsvolle Stabilitäts-Fixes, falls das “Einfrieren” nur daran lag:

1) Arduino: nicht blockierend lesen + Timeout-Fallback
Ersetze in deinem funktionierenden Arduino-Sketch den bisherigen Serial.readStringUntil('\n')-Teil durch diese Variante. So hängt er nicht fest, wenn mal kein \n kommt, und zeigt nach 5 s ohne neue Daten automatisch “Kein GPS-Signal …”.

// --------- oben bei den Globals ergänzen ---------
unsigned long lastRx = 0;
const unsigned long STALE_MS = 5000;   // 5 Sekunden ohne Daten => Meldung
// -------------------------------------------------

bool readLineNonBlocking(String &out) {
  static String buf;
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\r') continue;           // CR ignorieren
    if (c == '\n') {                   // Zeile komplett
      out = buf;
      buf = "";
      return true;
    }
    if (buf.length() < 160) buf += c;  // primitiver Schutz vor Überlauf
  }
  return false;
}

void showNoGPS() {
  // einfache Meldung unter dem Header
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.setCursor(MARGIN_X, HEADER_H + 40);
  tft.print("Kein GPS-Signal...");
}

// --------- in loop() ersetzen ---------
void loop() {
  String line;
  if (readLineNonBlocking(line)) {
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
      lastRx = millis();               // frische Daten
    }
  }

  // Fallback, wenn zu lange nichts kam
  if (millis() - lastRx > STALE_MS) {
    showNoGPS();
    // lastRx NICHT zurücksetzen -> bleibt in No-GPS, bis wieder Daten kommen
  }

  // kleine Pause, aber NICHT blockierend warten
  delay(5);
}
2) Pi: kontinuierlich senden + flush + Auto-Reconnect
Sorge dafür, dass dein Pi-Script jede Sekunde die aktuelle Anweisung schickt (auch wenn sie unverändert ist). So bleibt das Display aktiv und dein Arduino-Timeout springt nicht unnötig an.

import serial, time, sys

PORT = "/dev/ttyUSB0"   # ggf. anpassen
BAUD = 115200

def open_serial():
    while True:
        try:
            return serial.Serial(PORT, BAUD, timeout=1)
        except Exception as e:
            print("Serial open failed:", e)
            time.sleep(1)

ser = open_serial()

def send(code, dist, street, direc):
    line = f"{code}|{dist}|{street}|{direc}\n"
    ser.write(line.encode("utf-8"))
    ser.flush()

while True:
    try:
        # TODO: Hol dir hier deine echte Navi-Info.
        # send("STRAIGHT", "350 m", "Mülitobelstrasse", "Norden")
        # Beispiel: immer senden – auch wenn sich nichts ändert:
        # (Ersetze das obere durch deine echten Variablen.)
        time.sleep(1.0)
    except serial.SerialException:
        try: ser.close()
        except: pass
        ser = open_serial()
    except Exception as e:
        print("ERR:", e, file=sys.stderr)
        time.sleep(0.5)
Wichtig: Schicke nur \n (LF) als Zeilenende – CR (\r) lassen wir auf dem Arduino ohnehin fallen.

Schick mir jetzt bitte:

das Arduino-.ino (deine aktuelle Version),

das Pi-Python-Script, das während der Fahrt lief,

und 10–20 Zeilen der echten Pi-Ausgabe, die an den Arduino ging.

Dann pinpointen wir die Stelle, die das Stoppen verursacht hat (typisch: blockierendes Lesen am Arduino oder ein Pi-Loop, der nach 1–2 Anweisungen nicht weiter sendet).

Du:
hier ist der Arduino Code:
#include <Arduino.h>
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße deiner Bitmaps (64x64)
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px
const int MARGIN_X = 12;

const long BAUD = 115200;

// Status
String lastLine = "";

// ===================== Datenstruktur =====================
struct NavData {
  String code;       // "STRAIGHT", "LEFT", ...
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse" (mit Umlaut-Ersatz)
  String direction;  // "Norden"
};

// ===================== Hilfsfunktionen ===================

void sanitize(String &s) {
  // UTF-8 BOM entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  // Steuerzeichen & CR raus
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// UTF-8-Umlaute → ASCII (weil Adafruit_GFX kein UTF-8 kann)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    idx = s.indexOf(pat, left.length() + strlen(ascii));
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// in Pixel begrenzen, mit "..."
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;                 // 5x7 Font + 1 Spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (1x,2x,3x …)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);
  if (s < 1) s = 1;

  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// ===================== Parsing =====================

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

void parseFreeText(const String &text, NavData &out) {
  String t = text;

  // Distanz: erste Zahl (+ optional 'm')
  int iNum = -1;
  for (int i = 0; i < (int)t.length(); i++) {
    if (isDigit(t[i])) { iNum = i; break; }
  }
  if (iNum >= 0) {
    int j = iNum;
    while (j < (int)t.length() && (isDigit(t[j]) || t[j]==' ')) j++;
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) j++;
    out.distance = num + " m";
  }

  // Straße: zwischen "auf " und " Richtung"
  int iAuf   = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }

  // Richtung: nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }

  if (out.street.length()==0)    out.street = " ";
  if (out.direction.length()==0) out.direction = "";
  if (out.distance.length()==0)  out.distance = "";
}

NavData parseInstruction(const String &line) {
  NavData nd;
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      int p3 = rest.indexOf('|', p2 + 1);
      nd.distance = rest.substring(0, p2);          nd.distance.trim();
      if (p3 >= 0) {
        nd.street    = rest.substring(p2+1, p3);    nd.street.trim();
        nd.direction = rest.substring(p3+1);        nd.direction.trim();
      } else {
        parseFreeText(rest, nd);
      }
    } else {
      parseFreeText(rest, nd);
    }
  } else {
    parseFreeText(line, nd);
  }
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// ===================== Darstellung =====================

void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10;
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

// ===================== API wie bisher =====================

void showInstruction(const String &line) {
  if (line == lastLine) return;
  lastLine = line;

  NavData nd = parseInstruction(line);
  showCompact(nd);
}

// ===================== Setup / Loop =====================

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
}

void loop() {
  if (Serial.available()) {
    String line = Serial.readStringUntil('\n');
    line.trim();
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
    }
  }
}

Hier ist der Pi Code:
# -*- coding: utf-8 -*-
# >>> ZIEL & MAUT (nur diese 3 Zeilen bei Bedarf ändern) <<<
DST_LAT = 47.1662         # Ziel-Breitengrad
DST_LON = 8.5160          # Ziel-Längengrad
EXCLUDE_TOLLS = True      # True = Maut vermeiden, False = Maut erlaubt

# ===== ab hier nichts mehr ändern, außer Port/Baud falls nötig =====
import json, subprocess, time, threading, os, sys, re
import RPi.GPIO as GPIO
import serial

# Hardware/Timing
BTN_PIN   = 26                     # BCM 26 (physischer Pin 37), Taster gegen GND → Start Navigation
BTN_GPSD  = 19                     # BCM 19 (physischer Pin 35), Taster gegen GND → gpsd restart
SERIAL_DEV = "/dev/ttyACM0"        # Arduino-Display (ggf. /dev/serial/by-id/... nutzen)
BAUD       = 115200                # muss zum Arduino-Sketch passen
INTERVAL   = 3                     # Sekunden zwischen Aktualisierungen
VALHALLA_URL = "http://localhost:8002/route"

_running = False
_stop    = False

# ---------------- GPS ----------------
def _get_gps(timeout_s=6):
    """Liest eine gültige GPS-Position (mode 2/3) via gpsd/gpspipe."""
    p = subprocess.Popen(["gpspipe", "-w", "-n", "60"],
                         stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    start = time.time()
    try:
        for raw in p.stdout:
            if time.time() - start > timeout_s:
                break
            try:
                o = json.loads(raw.decode("utf-8", "ignore"))
            except Exception:
                continue
            if o.get("class") == "TPV" and o.get("mode") in (2, 3):
                lat, lon = o.get("lat"), o.get("lon")
                if lat is not None and lon is not None:
                    return float(lat), float(lon)
    finally:
        try: p.terminate()
        except Exception: pass
    return None

# ---------------- Valhalla → CODE|TEXT ----------------
# Valhalla maneuver type (int) → grobe Kategorie
LEFT_TYPES   = {14, 15, 13}                 # left, slight_left, sharp_left
RIGHT_TYPES  = {9, 8, 10}                    # right, slight_right, sharp_right
STRAIGHT_TYPES = {7, 20}                     # continue, stay_straight (häufig 7)
MERGE_TYPES  = {23, 16, 17, 21, 22}          # merge, ramp_right/left, stay_right/left
RA_ENTER     = 24
RA_EXIT      = 25

def _mk_icon_code(m):
    """Erzeugt einen Icon-Code für den ersten Maneuver-Eintrag."""
    t = m.get("type")
    if t in STRAIGHT_TYPES:
        return "STRAIGHT"
    if t in LEFT_TYPES:
        return "LEFT"
    if t in RIGHT_TYPES:
        return "RIGHT"
    if t == RA_EXIT:
        n = int(m.get("roundabout_exit_count", 0)) or 0
        if 1 <= n <= 9:
            return f"RA{n}"
        return "STRAIGHT"  # fallback
    if t == RA_ENTER:
        # beim Einfahren noch keine Ausfahrtzahl → neutrales Kreisverkehr-Symbol:
        return "RA1"
    if t in MERGE_TYPES:
        # links/rechts aus Text ableiten
        txt = (m.get("verbal_pre_transition_instruction") or m.get("instruction") or "").lower()
        if "rechts" in txt:
            return "MERGE_R"
        if "links" in txt:
            return "MERGE_L"
        # manchmal trägt Valhalla die Richtung in "begin_street_names" – schwer abzuleiten -> neutral
        return "STRAIGHT"
    # sonst versuchen, aus Text zu schätzen
    txt = (m.get("verbal_pre_transition_instruction") or "").lower()
    if "kreisverkehr" in txt:
        # Ausfahrtszahl aus Text fischen (1-9)
        mnum = re.search(r"\b([1-9])\.\s*ausfahrt\b", txt)
        if mnum:
            return f"RA{mnum.group(1)}"
        return "RA1"
    if "rechts" in txt:
        return "RIGHT"
    if "links" in txt:
        return "LEFT"
    return "STRAIGHT"

def _nice_distance_km_to_de(dist_km):
    """0.12 km → '120 m', 1.3 km → '1.3 km'"""
    if dist_km is None:
        return None
    try:
        d = float(dist_km)
    except Exception:
        return None
    if d < 0.995:
        return f"{int(round(d*1000))} m"
    return f"{d:.1f} km".replace(".", ",")

def _valhalla_first_code_and_text(cur_lat, cur_lon):
    """Fragt Valhalla und gibt 'CODE|TEXT' (oder nur TEXT) für das erste Manöver zurück."""
    payload = {
        "locations": [{"lat": cur_lat, "lon": cur_lon},
                      {"lat": DST_LAT, "lon": DST_LON}],
        "costing": "auto",
        "directions_options": {"language": "de-DE", "units": "kilometers"}
    }
    if EXCLUDE_TOLLS:
        payload["costing_options"] = {"auto": {"exclude_tolls": True}}

    try:
        res = subprocess.run(
            ["curl", "-s", "-H", "Content-Type: application/json",
             "-X", "POST", VALHALLA_URL, "-d", json.dumps(payload)],
            capture_output=True, text=True, timeout=10
        )
        data = json.loads(res.stdout)
        m = data["trip"]["legs"][0]["maneuvers"][0]

        # Icon-Code
        code = _mk_icon_code(m)

        # Text: Distanz + Straßenname + Verbalinstruktion
        dist = _nice_distance_km_to_de(m.get("length"))              # km → hübsch
        streets = m.get("street_names") or m.get("begin_street_names") or []
        street = streets[0] if streets else None
        verb = m.get("verbal_pre_transition_instruction") or m.get("instruction") or ""

        parts = []
        if dist: parts.append(f"In {dist}")
        if street: parts.append(street)
        # Nur anhängen, wenn der verbale Teil nicht schon Straßennamen/Distanz wiederholt
        if verb:
            parts.append(verb)

        # Doppelungen vermeiden
        text = " – ".join([p for p in parts if p])

        if code:
            return f"{code}|{text}" if text else code
        return text or "Keine Route verfügbar"
    except Exception:
        return None

# ---------------- Serial ----------------
def _open_serial_blocking(dev, baud):
    """Öffnet die serielle Schnittstelle, wartet bis das Gerät verfügbar ist."""
    while True:
        try:
            ser = serial.Serial(dev, baud, timeout=2)
            try: ser.setDTR(False)  # Auto-Reset vermeiden
            except Exception: pass
            time.sleep(2)          # Reset abwarten
            return ser
        except Exception:
            time.sleep(1)

# ---------------- Navigation Loop ----------------
def _nav_loop():
    global _running, _stop
    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
    last_line = None
    print("Navigation gestartet (Loop).")
    try:
        while not _stop:
            fix = _get_gps(timeout_s=6)
            if not fix:
                line = "Kein GPS Empfang"
            else:
                line = _valhalla_first_code_and_text(*fix)
                if not line:
                    line = "Keine Route verfügbar"

            if line != last_line:
                try:
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                except Exception:
                    try: ser.close()
                    except Exception: pass
                    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                last_line = line

            time.sleep(INTERVAL)
    finally:
        try: ser.close()
        except Exception: pass
        _running = False
        _stop = False
        print("Navigation beendet.")

def _start_nav():
    global _running, _stop
    if _running: return
    _stop = False
    _running = True
    threading.Thread(target=_nav_loop, daemon=True).start()

# ---------------- GPSD Restart ----------------
def _restart_gpsd():
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd.socket"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print("gpsd neu gestartet")

def _gpsd_button_watcher():
    last = GPIO.input(BTN_GPSD)
    while True:
        cur = GPIO.input(BTN_GPSD)
        if last == GPIO.HIGH and cur == GPIO.LOW:
            time.sleep(0.05)  # Entprellen
            if GPIO.input(BTN_GPSD) == GPIO.LOW:
                _restart_gpsd()
                while GPIO.input(BTN_GPSD) == GPIO.LOW:
                    time.sleep(0.02)
        last = cur
        time.sleep(0.02)

# ---------------- Main ----------------
def main():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)    # Startknopf
    GPIO.setup(BTN_GPSD, GPIO.IN, pull_up_down=GPIO.PUD_UP)   # GPSD-Knopf
    threading.Thread(target=_gpsd_button_watcher, daemon=True).start()
    print("Bereit. Drücke den Button (GPIO 26) um die Navigation zu starten.")
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                print("Button erkannt → starte Navigation.")
                _start_nav()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()


ChatGPT:

Nachgedacht für 1m 24s
Top – danke fürs Posten beider Skripte. Der „Freeze“ kommt ziemlich sicher daher, dass dein Pi-Script nur sendet, wenn sich der Text geändert hat (if line != last_line:). Der erste Schritt ändert sich, dann der zweite – und danach bleibt der Text oft identisch (Valhalla liefert dort keine „laufend kürzer werdende Distanz“, sondern eine konstante Manöver-Länge). Folge: Der Pi sendet nichts mehr → der Arduino bekommt nichts → es wirkt „eingefroren“.

Ich gebe dir jetzt beide Dateien komplett – mit zwei Fixes:

Pi: sendet jetzt jede INTERVAL-Sekunde die Anweisung (Keep-Alive), plus strukturierte Felder CODE|DISTANZ|STRASSE|RICHTUNG.

Arduino: hat einen No-GPS-Timeout (z.B. 6 s). Kommt in der Zeit nichts an, erscheint automatisch „Kein GPS-Signal…“. Außerdem versteht er das strukturierte Format direkt.

Arduino (komplett)
Datei: Display_Graphisch_v1.ino

#include <Arduino.h>
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße deiner Bitmaps (64x64)
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px
const int MARGIN_X = 12;

const long BAUD = 115200;

// --------- Watchdog / Keepalive ----------
unsigned long lastRx = 0;
const unsigned long STALE_MS = 6000;   // 6 Sekunden ohne Daten => "Kein GPS-Signal…"

// Status
String lastLine = "";

// ===================== Datenstruktur =====================
struct NavData {
  String code;       // "STRAIGHT", "LEFT", ...
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse" (mit Umlaut-Ersatz)
  String direction;  // "Norden"
};

// ===================== Hilfsfunktionen ===================

void sanitize(String &s) {
  // UTF-8 BOM entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  // Steuerzeichen & CR raus
  while (s.length() > 0 && (uint8_t)s[0] <= 0x1F) s.remove(0, 1);
  s.replace("\r", "");
}

// UTF-8-Umlaute → ASCII (weil Adafruit_GFX kein UTF-8 kann)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    idx = s.indexOf(pat, left.length() + strlen(ascii));
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// in Pixel begrenzen, mit "..."
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;                 // 5x7 Font + 1 Spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (1x,2x,3x …)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);
  if (s < 1) s = 1;

  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// ===================== Parsing =====================

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

// Erwartetes Format (vom Pi):
// "CODE|DISTANZ|STRASSE|RICHTUNG"
// Fallback: "CODE|FREIER TEXT" oder nur "FREIER TEXT"
void parseFreeText(const String &text, NavData &out) {
  String t = text;

  // Distanz: erste Zahl (+ optional 'm')
  int iNum = -1;
  for (int i = 0; i < (int)t.length(); i++) {
    if (isDigit(t[i])) { iNum = i; break; }
  }
  if (iNum >= 0) {
    int j = iNum;
    while (j < (int)t.length() && (isDigit(t[j]) || t[j]==' ')) j++;
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) j++;
    out.distance = num + " m";
  }

  // Straße: zwischen "auf " und " Richtung"
  int iAuf   = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }

  // Richtung: nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }

  if (out.street.length()==0)    out.street = " ";
  if (out.direction.length()==0) out.direction = "";
  if (out.distance.length()==0)  out.distance = "";
}

NavData parseInstruction(const String &line) {
  NavData nd;
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      int p3 = rest.indexOf('|', p2 + 1);
      if (p3 >= 0) {
        // CODE|DIST|STREET|DIR
        nd.distance = rest.substring(0, p2);          nd.distance.trim();
        nd.street    = rest.substring(p2+1, p3);      nd.street.trim();
        nd.direction = rest.substring(p3+1);          nd.direction.trim();
      } else {
        // CODE|FREITEXT
        parseFreeText(rest, nd);
      }
    } else {
      // CODE (ohne Text)
      // nichts weiter
    }
  } else {
    // Nur Freitext
    parseFreeText(line, nd);
  }
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// ===================== Darstellung =====================

void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10;
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

void showNoGPS() {
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.setCursor(MARGIN_X, HEADER_H + 40);
  tft.print("Kein GPS-Signal...");
}

// ===================== API wie bisher =====================

void showInstruction(const String &line) {
  // (Du kannst die nächste Zeile auskommentieren, wenn du JEDESMAL neu zeichnen willst)
  if (line == lastLine) return;
  lastLine = line;

  NavData nd = parseInstruction(line);
  showCompact(nd);
}

// ============== Serielle Eingabe (nicht-blockierend) ==============

bool readLineNonBlocking(String &out) {
  static String buf;
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\r') continue;
    if (c == '\n') {
      out = buf;
      buf = "";
      return true;
    }
    if (buf.length() < 240) buf += c; // simple Überlaufbremse
  }
  return false;
}

// ===================== Setup / Loop =====================

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
  lastRx = millis();
}

void loop() {
  String line;
  if (readLineNonBlocking(line)) {
    sanitize(line);
    if (line.length() > 0) {
      showInstruction(line);
      lastRx = millis();        // frische Daten eingetroffen
    }
  }

  // Timeout: längere Funkstille → No-GPS-Hinweis
  if (millis() - lastRx > STALE_MS) {
    showNoGPS();
    // lastRx NICHT zurücksetzen – bleibt, bis wieder Daten kommen
  }

  delay(5);
}
Raspberry Pi (komplett)
Datei: valhalla_serial_out.py

# -*- coding: utf-8 -*-
# >>> ZIEL & MAUT (nur diese 3 Zeilen bei Bedarf ändern) <<<
DST_LAT = 47.1662         # Ziel-Breitengrad
DST_LON = 8.5160          # Ziel-Längengrad
EXCLUDE_TOLLS = True      # True = Maut vermeiden, False = Maut erlaubt

# ===== ab hier nichts mehr ändern, außer Port/Baud falls nötig =====
import json, subprocess, time, threading, os, sys, re
import RPi.GPIO as GPIO
import serial

# Hardware/Timing
BTN_PIN    = 26                    # BCM 26 (Pin 37)  → Start Navigation
BTN_GPSD   = 19                    # BCM 19 (Pin 35)  → gpsd restart
SERIAL_DEV = "/dev/ttyACM0"        # Arduino-Display
BAUD       = 115200
INTERVAL   = 3                     # Sekunden zwischen Aktualisierungen
VALHALLA_URL = "http://localhost:8002/route"

_running = False
_stop    = False

# ---------------- GPS ----------------
def _get_gps(timeout_s=6):
    """Liest eine gültige GPS-Position (mode 2/3) via gpsd/gpspipe."""
    p = subprocess.Popen(["gpspipe", "-w", "-n", "60"],
                         stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    start = time.time()
    try:
        for raw in p.stdout:
            if time.time() - start > timeout_s:
                break
            try:
                o = json.loads(raw.decode("utf-8", "ignore"))
            except Exception:
                continue
            if o.get("class") == "TPV" and o.get("mode") in (2, 3):
                lat, lon = o.get("lat"), o.get("lon")
                if lat is not None and lon is not None:
                    return float(lat), float(lon)
    finally:
        try: p.terminate()
        except Exception: pass
    return None

# ---------------- Valhalla → strukturierte Ausgabe ----------------
LEFT_TYPES      = {14, 15, 13}
RIGHT_TYPES     = {9, 8, 10}
STRAIGHT_TYPES  = {7, 20}
MERGE_TYPES     = {23, 16, 17, 21, 22}
RA_ENTER        = 24
RA_EXIT         = 25

def _mk_icon_code(m):
    t = m.get("type")
    if t in STRAIGHT_TYPES:
        return "STRAIGHT"
    if t in LEFT_TYPES:
        return "LEFT"
    if t in RIGHT_TYPES:
        return "RIGHT"
    if t == RA_EXIT:
        n = int(m.get("roundabout_exit_count", 0)) or 0
        if 1 <= n <= 9:
            return f"RA{n}"
        return "STRAIGHT"
    if t == RA_ENTER:
        return "RA1"
    if t in MERGE_TYPES:
        txt = (m.get("verbal_pre_transition_instruction") or m.get("instruction") or "").lower()
        if "rechts" in txt:
            return "MERGE_R"
        if "links" in txt:
            return "MERGE_L"
        return "STRAIGHT"
    txt = (m.get("verbal_pre_transition_instruction") or "").lower()
    if "kreisverkehr" in txt:
        mnum = re.search(r"\b([1-9])\.\s*ausfahrt\b", txt)
        if mnum:
            return f"RA{mnum.group(1)}"
        return "RA1"
    if "rechts" in txt:
        return "RIGHT"
    if "links" in txt:
        return "LEFT"
    return "STRAIGHT"

def _nice_distance_km_to_de(dist_km):
    if dist_km is None:
        return ""
    try:
        d = float(dist_km)
    except Exception:
        return ""
    if d < 0.995:
        return f"{int(round(d*1000))} m"
    return f"{d:.1f} km".replace(".", ",")

def _extract_direction(verb):
    """
    Versucht 'Richtung Norden' aus dem Valhalla-Text zu fischen.
    Liefert nur das Wort nach 'Richtung' (z.B. 'Norden'), sonst ''.
    """
    if not verb:
        return ""
    m = re.search(r"richtung\s+([a-zäöüß]+)", verb, flags=re.IGNORECASE)
    if not m:
        return ""
    dirw = m.group(1)
    # Erste Buchstabe groß
    return dirw[:1].upper() + dirw[1:]

def _valhalla_first_compact(cur_lat, cur_lon):
    """
    Fragt Valhalla und gibt 'CODE|DIST|STREET|DIR' zurück.
    """
    payload = {
        "locations": [{"lat": cur_lat, "lon": cur_lon},
                      {"lat": DST_LAT, "lon": DST_LON}],
        "costing": "auto",
        "directions_options": {"language": "de-DE", "units": "kilometers"}
    }
    if EXCLUDE_TOLLS:
        payload["costing_options"] = {"auto": {"exclude_tolls": True}}

    res = subprocess.run(
        ["curl", "-s", "-H", "Content-Type: application/json",
         "-X", "POST", VALHALLA_URL, "-d", json.dumps(payload)],
        capture_output=True, text=True, timeout=10
    )
    data = json.loads(res.stdout)
    m = data["trip"]["legs"][0]["maneuvers"][0]

    code  = _mk_icon_code(m)
    dist  = _nice_distance_km_to_de(m.get("length"))
    streets = m.get("street_names") or m.get("begin_street_names") or []
    street  = streets[0] if streets else ""
    verb    = m.get("verbal_pre_transition_instruction") or m.get("instruction") or ""
    direc   = _extract_direction(verb)

    # Sicherstellen, dass keine '|' drin ist
    for repl in ("|", "\n", "\r"):
        street = street.replace(repl, " ")
        direc  = direc.replace(repl, " ")

    # Immer 4 Felder schicken (leere Felder erlaubt)
    return f"{code}|{dist}|{street}|{direc}"

# ---------------- Serial ----------------
def _open_serial_blocking(dev, baud):
    while True:
        try:
            ser = serial.Serial(dev, baud, timeout=2)
            try: ser.setDTR(False)  # Auto-Reset vermeiden
            except Exception: pass
            time.sleep(2)
            return ser
        except Exception as e:
            print("Warte auf Serial:", e)
            time.sleep(1)

# ---------------- Navigation Loop ----------------
def _nav_loop():
    global _running, _stop
    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
    print("Navigation gestartet (Loop).")
    try:
        while not _stop:
            fix = _get_gps(timeout_s=6)
            if not fix:
                line = "Kein GPS Empfang"
            else:
                try:
                    line = _valhalla_first_compact(*fix)
                except Exception as e:
                    print("Valhalla-Fehler:", e)
                    line = "Keine Route verfügbar"

            # WICHTIG: immer senden (Keep-Alive), nicht nur bei Änderung!
            try:
                ser.write((line + "\n").encode("utf-8"))
                ser.flush()
                print("→", line)
            except Exception as e:
                print("Serial-Fehler:", e)
                try: ser.close()
                except Exception: pass
                ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                ser.write((line + "\n").encode("utf-8"))
                ser.flush()

            time.sleep(INTERVAL)
    finally:
        try: ser.close()
        except Exception: pass
        _running = False
        _stop = False
        print("Navigation beendet.")

def _start_nav():
    global _running, _stop
    if _running: return
    _stop = False
    _running = True
    threading.Thread(target=_nav_loop, daemon=True).start()

# ---------------- GPSD Restart ----------------
def _restart_gpsd():
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd.socket"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print("gpsd neu gestartet")

def _gpsd_button_watcher():
    last = GPIO.input(BTN_GPSD)
    while True:
        cur = GPIO.input(BTN_GPSD)
        if last == GPIO.HIGH and cur == GPIO.LOW:
            time.sleep(0.05)  # Entprellen
            if GPIO.input(BTN_GPSD) == GPIO.LOW:
                _restart_gpsd()
                while GPIO.input(BTN_GPSD) == GPIO.LOW:
                    time.sleep(0.02)
        last = cur
        time.sleep(0.02)

# ---------------- Main ----------------
def main():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)    # Startknopf
    GPIO.setup(BTN_GPSD, GPIO.IN, pull_up_down=GPIO.PUD_UP)   # GPSD-Knopf
    threading.Thread(target=_gpsd_button_watcher, daemon=True).start()
    print("Bereit. Drücke den Button (GPIO 26) um die Navigation zu starten.")
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                print("Button erkannt → starte Navigation.")
                _start_nav()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()
Kurzfassung, was sich geändert hat
Pi: sendet jetzt immer (Keep-Alive), plus strukturierte Felder CODE|DIST|STRASSE|RICHTUNG, damit der Arduino schön Block-Layout zeichnen kann.

Arduino: zeigt nach 6 s Funkstille automatisch „Kein GPS-Signal…“ und liest die serielle Schnittstelle nicht-blockierend.

Teste das bitte genau so. Wenn es unterwegs wieder „stehen bleibt“, poste mir die letzten 20 Zeilen Pi-Konsolen-Output (da siehst du jetzt jede gesendete Zeile mit → ...). Damit können wir sofort sehen, ob der Pi weiter sendet oder ob es am Display/USB hängt.

Du:
jetzt blinkt der Text auf dem Display einfach ganz schnell, da es ständig aktualisiert, unabhängig ob sich die Anweisung geändert hat oder immernoch diesselbe ist
ChatGPT:

Nachgedacht für 1m 3s
Got it — das schnelle Blinken kommt daher, dass der Pi jetzt immer sendet und der Arduino jedes Mal neu zeichnet. Hier ist eine robuste Lösung:

Pi sendet weiter regelmäßig, aber wenn sich die Anweisung nicht geändert hat, schickt er nur einen Heartbeat "PING" (kein Redraw).

Arduino: ignoriert "PING" (nutzt es nur als Keep-Alive), zeichnet nur bei echter Änderung. Außerdem trimmt/normalisiert er die Zeile vor dem Vergleich, damit kleine Unterschiede (Spaces) kein Redraw auslösen. Der „Kein GPS-Signal…“-Hinweis bleibt erhalten (Timeout).

Unten beide Dateien komplett.

Arduino (komplett) — Display_Graphisch_v1.ino
#include <Arduino.h>
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Display Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße deiner Bitmaps (64x64)
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px
const int MARGIN_X = 12;

const long BAUD = 115200;

// --------- Watchdog / Keepalive ----------
unsigned long lastRx = 0;
const unsigned long STALE_MS = 6000;   // 6 s ohne Daten => "Kein GPS-Signal…"

// Status
String lastKey = "";   // normalisierte Anweisungs-Signatur

// ===================== Datenstruktur =====================
struct NavData {
  String code;       // "STRAIGHT", "LEFT", ...
  String distance;   // "113 m"
  String street;     // "Muelitobelstrasse" (ASCII-Ersatz)
  String direction;  // "Norden"
};

// ===================== Hilfsfunktionen ===================

void sanitize(String &s) {
  // UTF-8 BOM entfernen
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  // CR & Steuerzeichen raus
  s.replace("\r", "");
  // trimmen
  s.trim();
}

// UTF-8-Umlaute → ASCII (weil Adafruit_GFX kein UTF-8 kann)
void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    idx = s.indexOf(pat, left.length() + strlen(ascii));
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

// in Pixel begrenzen, mit "..."
String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;                 // 5x7 Font + 1 Spacing
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

// 1-bit Bitmap skaliert zeichnen (1x,2x,3x …)
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);
  if (s < 1) s = 1;

  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icon anhand Code
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return nullptr;
}

// ===================== Parsing =====================

void trimWord(String &s) {
  s.trim();
  while (s.endsWith(".") || s.endsWith(",") || s.endsWith(";")) s.remove(s.length()-1);
  s.trim();
}

// Fallback-Parser für freie Texte
void parseFreeText(const String &text, NavData &out) {
  String t = text;

  // Distanz: erste Zahl (+ optional 'm')
  int iNum = -1;
  for (int i = 0; i < (int)t.length(); i++) {
    if (isDigit(t[i])) { iNum = i; break; }
  }
  if (iNum >= 0) {
    int j = iNum;
    while (j < (int)t.length() && (isDigit(t[j]) || t[j]==' ')) j++;
    String num = t.substring(iNum, j); num.trim();
    if (j < (int)t.length() && (t[j]=='m' || t[j]=='M')) j++;
    out.distance = num + " m";
  }

  // Straße: zwischen "auf " und " Richtung"
  int iAuf   = t.indexOf("auf ");
  int iRicht = t.indexOf("Richtung");
  if (iAuf >= 0) {
    int start = iAuf + 4;
    int end = (iRicht > start) ? iRicht : t.indexOf(' ', start + 1);
    if (end < 0) end = t.length();
    out.street = t.substring(start, end);
    trimWord(out.street);
  }

  // Richtung: nach "Richtung "
  if (iRicht >= 0) {
    int start = iRicht + 8;
    int end = t.indexOf(' ', start);
    if (end < 0) end = t.length();
    out.direction = t.substring(start, end);
    trimWord(out.direction);
  }

  if (out.street.length()==0)    out.street = " ";
  if (out.direction.length()==0) out.direction = "";
  if (out.distance.length()==0)  out.distance = "";
}

// Erwartetes Format vom Pi: "CODE|DISTANZ|STRASSE|RICHTUNG"
NavData parseInstruction(const String &line) {
  NavData nd;
  int p1 = line.indexOf('|');
  if (p1 >= 0) {
    nd.code = line.substring(0, p1);
    String rest = line.substring(p1 + 1);
    int p2 = rest.indexOf('|');
    if (p2 >= 0) {
      int p3 = rest.indexOf('|', p2 + 1);
      if (p3 >= 0) {
        nd.distance = rest.substring(0, p2);          nd.distance.trim();
        nd.street    = rest.substring(p2+1, p3);      nd.street.trim();
        nd.direction = rest.substring(p3+1);          nd.direction.trim();
      } else {
        parseFreeText(rest, nd);
      }
    }
  } else {
    parseFreeText(line, nd);
  }
  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.direction);
  return nd;
}

// erzeugt eine kompakte Signatur zum Duplikat-Check
String makeKey(const NavData &nd) {
  String k = nd.code; k += '|'; k += nd.distance; k += '|'; k += nd.street; k += '|'; k += nd.direction;
  k.trim();
  return k;
}

// ===================== Darstellung =====================

void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // Distanz (groß)
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 10;
  }

  // Straße (mittel)
  if (nd.street.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String street = ellipsizeToWidth(nd.street, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(street);
    lineY += 8*2 + 6;
  }

  // Richtung (mittel)
  if (nd.direction.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = "Richtung " + nd.direction;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 4;
  }
}

void showNoGPS() {
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.setCursor(MARGIN_X, HEADER_H + 40);
  tft.print("Kein GPS-Signal...");
}

// ============== Serielle Eingabe (nicht-blockierend) ==============
bool readLineNonBlocking(String &out) {
  static String buf;
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\r') continue;
    if (c == '\n') {
      out = buf;
      buf = "";
      return true;
    }
    if (buf.length() < 240) buf += c;
  }
  return false;
}

// ===================== Setup / Loop =====================

void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);           // Landscape
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  delay(300);
  while (Serial.available()) Serial.read();
  lastRx = millis();
}

void loop() {
  String line;
  if (readLineNonBlocking(line)) {
    sanitize(line);
    lastRx = millis();            // jede eingehende Zeile hält GPS-Timeout wach

    // Heartbeat ignorieren (kein Redraw)
    if (line == "PING") {
      return;
    }

    // Spezielle Textfälle (ohne Redraw-Sturm)
    if (line.equalsIgnoreCase("Kein GPS Empfang")) {
      if (lastKey != "NO_GPS") {
        showNoGPS();
        lastKey = "NO_GPS";
      }
      return;
    }
    if (line.equalsIgnoreCase("Keine Route verfügbar")) {
      if (lastKey != "NO_ROUTE") {
        tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);
        tft.setTextColor(WHITE, BLACK);
        tft.setTextSize(2);
        tft.setCursor(MARGIN_X, HEADER_H + 40);
        tft.print("Keine Route verfuegbar");
        lastKey = "NO_ROUTE";
      }
      return;
    }

    // Normale Anweisung
    NavData nd = parseInstruction(line);
    String key = makeKey(nd);
    if (key == lastKey) {
      // identisch → kein Redraw
      return;
    }
    showCompact(nd);
    lastKey = key;
  }

  // Timeout: längere Funkstille → No-GPS-Hinweis
  if (millis() - lastRx > STALE_MS) {
    if (lastKey != "NO_GPS") {
      showNoGPS();
      lastKey = "NO_GPS";
    }
  }

  delay(5);
}
Raspberry Pi (komplett) — valhalla_serial_out.py
# -*- coding: utf-8 -*-
# >>> ZIEL & MAUT (nur diese 3 Zeilen bei Bedarf ändern) <<<
DST_LAT = 47.1662         # Ziel-Breitengrad
DST_LON = 8.5160          # Ziel-Längengrad
EXCLUDE_TOLLS = True      # True = Maut vermeiden, False = Maut erlaubt

# ===== ab hier nichts mehr ändern, außer Port/Baud falls nötig =====
import json, subprocess, time, threading, re
import RPi.GPIO as GPIO
import serial

# Hardware/Timing
BTN_PIN    = 26                   # BCM 26 (Pin 37)  → Start Navigation
BTN_GPSD   = 19                   # BCM 19 (Pin 35)  → gpsd restart
SERIAL_DEV = "/dev/ttyACM0"       # Arduino-Display
BAUD       = 115200
INTERVAL   = 3                    # Sekunden zwischen Aktualisierungen
VALHALLA_URL = "http://localhost:8002/route"

_running = False
_stop    = False

# ---------------- GPS ----------------
def _get_gps(timeout_s=6):
    p = subprocess.Popen(["gpspipe", "-w", "-n", "60"],
                         stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    start = time.time()
    try:
        for raw in p.stdout:
            if time.time() - start > timeout_s:
                break
            try:
                o = json.loads(raw.decode("utf-8", "ignore"))
            except Exception:
                continue
            if o.get("class") == "TPV" and o.get("mode") in (2, 3):
                lat, lon = o.get("lat"), o.get("lon")
                if lat is not None and lon is not None:
                    return float(lat), float(lon)
    finally:
        try: p.terminate()
        except Exception: pass
    return None

# ---------------- Valhalla → strukturierte Ausgabe ----------------
LEFT_TYPES      = {14, 15, 13}
RIGHT_TYPES     = {9, 8, 10}
STRAIGHT_TYPES  = {7, 20}
MERGE_TYPES     = {23, 16, 17, 21, 22}
RA_ENTER        = 24
RA_EXIT         = 25

def _mk_icon_code(m):
    t = m.get("type")
    if t in STRAIGHT_TYPES:
        return "STRAIGHT"
    if t in LEFT_TYPES:
        return "LEFT"
    if t in RIGHT_TYPES:
        return "RIGHT"
    if t == RA_EXIT:
        n = int(m.get("roundabout_exit_count", 0)) or 0
        if 1 <= n <= 9:
            return f"RA{n}"
        return "STRAIGHT"
    if t == RA_ENTER:
        return "RA1"
    if t in MERGE_TYPES:
        txt = (m.get("verbal_pre_transition_instruction") or m.get("instruction") or "").lower()
        if "rechts" in txt:
            return "MERGE_R"
        if "links" in txt:
            return "MERGE_L"
        return "STRAIGHT"
    txt = (m.get("verbal_pre_transition_instruction") or "").lower()
    if "kreisverkehr" in txt:
        mnum = re.search(r"\b([1-9])\.\s*ausfahrt\b", txt)
        if mnum:
            return f"RA{mnum.group(1)}"
        return "RA1"
    if "rechts" in txt:
        return "RIGHT"
    if "links" in txt:
        return "LEFT"
    return "STRAIGHT"

def _nice_distance_km_to_de(dist_km):
    if dist_km is None:
        return ""
    try:
        d = float(dist_km)
    except Exception:
        return ""
    if d < 0.995:
        return f"{int(round(d*1000))} m"
    return f"{d:.1f} km".replace(".", ",")

def _extract_direction(verb):
    if not verb:
        return ""
    m = re.search(r"richtung\s+([a-zäöüß]+)", verb, flags=re.IGNORECASE)
    if not m:
        return ""
    dirw = m.group(1)
    return dirw[:1].upper() + dirw[1:]

def _valhalla_first_compact(cur_lat, cur_lon):
    payload = {
        "locations": [{"lat": cur_lat, "lon": cur_lon},
                      {"lat": DST_LAT, "lon": DST_LON}],
        "costing": "auto",
        "directions_options": {"language": "de-DE", "units": "kilometers"}
    }
    if EXCLUDE_TOLLS:
        payload["costing_options"] = {"auto": {"exclude_tolls": True}}

    res = subprocess.run(
        ["curl", "-s", "-H", "Content-Type: application/json",
         "-X", "POST", VALHALLA_URL, "-d", json.dumps(payload)],
        capture_output=True, text=True, timeout=10
    )
    data = json.loads(res.stdout)
    m = data["trip"]["legs"][0]["maneuvers"][0]

    code  = _mk_icon_code(m)
    dist  = _nice_distance_km_to_de(m.get("length"))
    streets = m.get("street_names") or m.get("begin_street_names") or []
    street  = streets[0] if streets else ""
    verb    = m.get("verbal_pre_transition_instruction") or m.get("instruction") or ""
    direc   = _extract_direction(verb)

    # Sicherstellen, dass keine '|'/Zeilenumbrüche drin sind
    for repl in ("|", "\n", "\r"):
        street = street.replace(repl, " ")
        direc  = direc.replace(repl, " ")

    return f"{code}|{dist}|{street}|{direc}"

# ---------------- Serial ----------------
def _open_serial_blocking(dev, baud):
    while True:
        try:
            ser = serial.Serial(dev, baud, timeout=2)
            try: ser.setDTR(False)
            except Exception: pass
            time.sleep(2)
            return ser
        except Exception:
            time.sleep(1)

# ---------------- Navigation Loop ----------------
def _nav_loop():
    global _running, _stop
    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
    last_instr = None  # zuletzt GESENDETE inhaltsgleiche Anweisung
    try:
        while not _stop:
            fix = _get_gps(timeout_s=6)
            if not fix:
                line = "Kein GPS Empfang"
                # bei No-GPS: sende immer den Text (damit Display das auch sieht)
                try:
                    ser.write((line + "\n").encode("utf-8")); ser.flush()
                except Exception:
                    try: ser.close()
                    except Exception: pass
                    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                    ser.write((line + "\n").encode("utf-8")); ser.flush()
                time.sleep(INTERVAL)
                continue

            try:
                instr = _valhalla_first_compact(*fix)  # "CODE|DIST|STREET|DIR"
            except Exception:
                instr = "Keine Route verfügbar"

            # Nur senden, wenn sich die Anweisung inhaltlich geändert hat.
            if instr != last_instr:
                msg = instr
                last_instr = instr
            else:
                msg = "PING"   # Heartbeat, kein Redraw auf dem Arduino

            try:
                ser.write((msg + "\n").encode("utf-8")); ser.flush()
            except Exception:
                try: ser.close()
                except Exception: pass
                ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                ser.write((msg + "\n").encode("utf-8")); ser.flush()

            time.sleep(INTERVAL)
    finally:
        try: ser.close()
        except Exception: pass
        _running = False
        _stop = False

def _start_nav():
    global _running, _stop
    if _running: return
    _stop = False
    _running = True
    threading.Thread(target=_nav_loop, daemon=True).start()

# ---------------- GPSD Restart + Button ----------------
def _restart_gpsd():
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd.socket"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(["sudo", "/usr/bin/systemctl", "restart", "gpsd"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def _gpsd_button_watcher():
    last = GPIO.input(BTN_GPSD)
    while True:
        cur = GPIO.input(BTN_GPSD)
        if last == GPIO.HIGH and cur == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_GPSD) == GPIO.LOW:
                _restart_gpsd()
                while GPIO.input(BTN_GPSD) == GPIO.LOW:
                    time.sleep(0.02)
        last = cur
        time.sleep(0.02)

# ---------------- Main ----------------
def main():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(BTN_GPSD, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    threading.Thread(target=_gpsd_button_watcher, daemon=True).start()
    print("Bereit. Button (GPIO 26) startet Navigation.")
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                _start_nav()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)

if __name__ == "__main__":
    import time
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()
Ergebnis: Kein Flackern mehr (Arduino zeichnet nur bei echter Änderung), trotzdem kein „Freeze“ (Heartbeat hält das Display wach). Wenn du magst, kannst du INTERVAL auf 2 s stellen – die Logik bleibt gleich.

Du:
es ist immernoch nicht so wie es sein sollte, hier nochmals wie das ganze funktionieren sollte: alle 3 sekunden wird die Route mit Valhalla auf dem Pi neu berechnet, falls die Ausgabe anders ist als die zuvor soll sie ans Arduino geschickt werden und dort auf dem Bildschirm aktualisiert werden. oder es wird alle 3 Sekunden geschickt und auf dem Arduino geprüft, ob die Anzeige akutalisiert werden muss. je nach dem was besser ist. auf dem Display sollte dann immer das dazugehörige Piktogramm angezeit werden. Die Kein GPS Signal Meldung kannst du vorerst weglassen. Wenn man abbiegen muss, dann sollte auch immer eine Distanz angezeigt werden. Wenn man auf einer Strasse geradeaus fährt bzw dem Strassenverlauf folgt, dann soll keine Distanz angegeben werden, dafür die Himmelsrichtung (ändert sich meistens nach jeder Kurve, aber das ist gut so). Zusätzlich soll immer der Strassenname angezeigt werden. nie fliesstext.
ChatGPT:

Nachgedacht für 1m 5s
alles klar — ich habe beide Skripte so überarbeitet, dass:

der Pi alle 3 s neu routet,

nur sendet, wenn sich die Inhalte (Icon/Distanz/Straße/Himmelsrichtung) geändert haben,

das Arduino immer das passende Piktogramm zeigt,

bei Abbiege-/Wechsel-Manövern immer eine Distanz gezeigt wird,

bei geradeaus / dem Straßenverlauf folgen keine Distanz, sondern die Himmelsrichtung (aus GPS-Heading) gezeigt wird,

immer der Straßenname angezeigt wird,

kein Fließtext mehr – nur strukturierte Felder.

Umlaute werden wie gehabt in ASCII ersetzt (ä→ae …), damit Adafruit-GFX sauber rendert.

Arduino (komplett) — Display_Graphisch_v1.ino
#include <Arduino.h>
#include <MCUFRIEND_kbv.h>
#include <Adafruit_GFX.h>
#include "bitmaps.h"   // deine 64x64 1-bit Bitmaps (PROGMEM)

MCUFRIEND_kbv tft;

// Farben
#define BLACK   0x0000
#define WHITE   0xFFFF
#define BLUE    0x001F

// Layout
const int SCREEN_W = 320;
const int SCREEN_H = 240;
const int HEADER_H = 30;
const int ICON_BASE = 64;          // Originalgröße 64x64
const float ICON_SCALE = 2.0f;     // 1.0=64px, 1.5=96px, 2.0=128px
const int MARGIN_X = 12;
const long BAUD = 115200;

// Status
String lastKey = "";

// -------- Datenstruktur ----------
struct NavData {
  String code;       // "STRAIGHT", "LEFT", ...
  String distance;   // "113 m" oder "" (leer = keine Distanz anzeigen)
  String street;     // "Muelitobelstrasse"
  String heading;    // "Norden" (nur wenn distance leer)
};

// -------- Hilfsfunktionen ----------
void sanitize(String &s) {
  if (s.length() >= 3 &&
      (uint8_t)s[0] == 0xEF && (uint8_t)s[1] == 0xBB && (uint8_t)s[2] == 0xBF) {
    s.remove(0, 3);
  }
  s.replace("\r", "");
  s.trim();
}

void replaceUTF8(String &s, const char* u8, const char* ascii) {
  String pat(u8);
  int idx = s.indexOf(pat);
  while (idx >= 0) {
    String left  = s.substring(0, idx);
    String right = s.substring(idx + pat.length());
    s = left + ascii + right;
    idx = s.indexOf(pat, left.length() + strlen(ascii));
  }
}

void fixUmlauts(String &s) {
  replaceUTF8(s, "\xC3\xA4", "ae"); // ä
  replaceUTF8(s, "\xC3\xB6", "oe"); // ö
  replaceUTF8(s, "\xC3\xBC", "ue"); // ü
  replaceUTF8(s, "\xC3\x84", "Ae"); // Ä
  replaceUTF8(s, "\xC3\x96", "Oe"); // Ö
  replaceUTF8(s, "\xC3\x9C", "Ue"); // Ü
  replaceUTF8(s, "\xC3\x9F", "ss"); // ß
}

String ellipsizeToWidth(const String &s, int maxPx, uint8_t textSize) {
  int charW = 6 * textSize;
  int maxChars = max(1, maxPx / charW);
  if ((int)s.length() <= maxChars) return s;
  if (maxChars <= 3) return String("...");
  return s.substring(0, maxChars - 3) + "...";
}

// 1-bit Bitmap skaliert zeichnen
void drawBitmapScaled1bpp(int16_t x, int16_t y, const uint8_t* bmp,
                          uint16_t w, uint16_t h, float scale, uint16_t color) {
  if (!bmp || scale <= 0.01f) return;
  uint16_t rowBytes = (w + 7) / 8;
  int s = (int)(scale + 0.5f);
  if (s < 1) s = 1;

  for (uint16_t yy = 0; yy < h; yy++) {
    for (uint16_t xx = 0; xx < w; xx++) {
      uint8_t b = pgm_read_byte(bmp + yy * rowBytes + (xx >> 3));
      if (b & (0x80 >> (xx & 7))) {
        tft.fillRect(x + xx * s, y + yy * s, s, s, color);
      }
    }
  }
}

// Icons
const uint8_t* iconFromCode(const String &code) {
  if (code == "STRAIGHT")  return epd_bitmap_Pfeil_geradeaus;
  if (code == "LEFT")      return epd_bitmap_Pfeil_links_abbiegen;
  if (code == "RIGHT")     return epd_bitmap_Pfeil_rechts_abbiegen;
  if (code == "MERGE_L")   return epd_bitmap_Pfeil_links_einspuren;
  if (code == "MERGE_R")   return epd_bitmap_Pfeil_rechts_einspuren;
  if (code == "RA1")       return epd_bitmap_Kreisverkehr2_1;
  if (code == "RA2")       return epd_bitmap_Kreisverkehr2_2;
  if (code == "RA3")       return epd_bitmap_Kreisverkehr2_3;
  if (code == "RA4")       return epd_bitmap_Kreisverkehr2_4;
  if (code == "RA5")       return epd_bitmap_Kreisverkehr2_5;
  if (code == "RA6")       return epd_bitmap_Kreisverkehr2_6;
  if (code == "RA7")       return epd_bitmap_Kreisverkehr2_7;
  if (code == "RA8")       return epd_bitmap_Kreisverkehr2_8;
  if (code == "RA9")       return epd_bitmap_Kreisverkehr2_9;
  return epd_bitmap_Pfeil_geradeaus;
}

// -------- Parsing ----------
NavData parseInstruction(const String &line) {
  // Format: CODE|DIST|STREET|HEADING
  NavData nd;
  int p1 = line.indexOf('|');
  int p2 = (p1 >= 0) ? line.indexOf('|', p1+1) : -1;
  int p3 = (p2 >= 0) ? line.indexOf('|', p2+1) : -1;

  if (p1 < 0) return nd; // leer → kein Draw

  nd.code = line.substring(0, p1);
  if (p2 > p1) nd.distance = line.substring(p1+1, p2);
  if (p3 > p2) nd.street   = line.substring(p2+1, p3);
  if (p3 > 0)  nd.heading  = line.substring(p3+1);

  nd.code.trim(); nd.distance.trim(); nd.street.trim(); nd.heading.trim();

  fixUmlauts(nd.distance);
  fixUmlauts(nd.street);
  fixUmlauts(nd.heading);
  return nd;
}

String makeKey(const NavData &nd) {
  String k = nd.code; k += '|'; k += nd.distance; k += '|'; k += nd.street; k += '|'; k += nd.heading;
  k.trim();
  return k;
}

// -------- Rendering ----------
void drawHeader() {
  tft.fillRect(0, 0, SCREEN_W, HEADER_H, BLUE);
  tft.setTextColor(WHITE, BLUE);
  tft.setTextSize(2);
  tft.setCursor(10, 7);
  tft.print("Valhalla Navigation");
}

void showCompact(const NavData &nd) {
  // Fläche unterhalb Header löschen
  tft.fillRect(0, HEADER_H, SCREEN_W, SCREEN_H - HEADER_H, BLACK);

  // Icon
  int iconX = MARGIN_X;
  int iconY = HEADER_H + 6;
  const uint8_t* bmp = iconFromCode(nd.code);
  int iconW = (int)(ICON_BASE * ICON_SCALE + 0.5f);

  int textX = MARGIN_X;
  int lineY = HEADER_H + 12;

  if (bmp) {
    drawBitmapScaled1bpp(iconX, iconY, bmp, ICON_BASE, ICON_BASE, ICON_SCALE, WHITE);
    textX = iconX + iconW + MARGIN_X;
    lineY = iconY + 4;
  }

  int availW = SCREEN_W - textX - MARGIN_X;

  // STREET (immer)
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  String street = ellipsizeToWidth(nd.street.length() ? nd.street : String(" "), availW, 2);
  tft.setCursor(textX, lineY);
  tft.print(street);
  lineY += 8*2 + 8;

  // Wenn Distanz vorhanden → groß anzeigen, KEINE Richtung
  if (nd.distance.length()) {
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(3);
    String dist = ellipsizeToWidth(nd.distance, availW, 3);
    tft.setCursor(textX, lineY);
    tft.print(dist);
    lineY += 8*3 + 8;
  } else if (nd.heading.length()) {
    // sonst Richtung (mittel)
    tft.setTextColor(WHITE, BLACK);
    tft.setTextSize(2);
    String rtxt = String("Richtung ") + nd.heading;
    rtxt = ellipsizeToWidth(rtxt, availW, 2);
    tft.setCursor(textX, lineY);
    tft.print(rtxt);
    lineY += 8*2 + 6;
  }
}

// -------- serielle Eingabe (non-blocking) --------
bool readLineNonBlocking(String &out) {
  static String buf;
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\r') continue;
    if (c == '\n') {
      out = buf; buf = "";
      return true;
    }
    if (buf.length() < 240) buf += c;
  }
  return false;
}

// -------- Setup / Loop --------
void setup() {
  Serial.begin(BAUD);
  uint16_t id = tft.readID();
  tft.begin(id);
  tft.setRotation(1);
  tft.fillScreen(BLACK);
  drawHeader();

  tft.setCursor(20, HEADER_H + 40);
  tft.setTextColor(WHITE, BLACK);
  tft.setTextSize(2);
  tft.print("Warte auf Anweisung...");

  while (Serial.available()) Serial.read();
}

void loop() {
  String line;
  if (readLineNonBlocking(line)) {
    sanitize(line);
    if (!line.length()) return;

    NavData nd = parseInstruction(line);
    String key = makeKey(nd);
    if (key == lastKey) return;      // keine Änderung → nicht neu zeichnen

    showCompact(nd);
    lastKey = key;
  }
  delay(5);
}
Raspberry Pi (komplett) — valhalla_serial_out.py
# -*- coding: utf-8 -*-
# >>> ZIEL & MAUT (nur diese 3 Zeilen bei Bedarf ändern) <<<
DST_LAT = 47.1662         # Ziel-Breitengrad
DST_LON = 8.5160          # Ziel-Längengrad
EXCLUDE_TOLLS = True      # True = Maut vermeiden, False = Maut erlaubt

# ===== ab hier nichts mehr ändern, außer Port/Baud falls nötig =====
import json, subprocess, time, threading, math, re
import RPi.GPIO as GPIO
import serial

# Hardware / Timing
BTN_PIN    = 26                 # BCM 26 (Pin 37)  → Start Navigation
SERIAL_DEV = "/dev/ttyACM0"     # Arduino-Display
BAUD       = 115200
INTERVAL   = 3                  # alle 3 s neu routen
VALHALLA_URL = "http://localhost:8002/route"

_running = False
_stop    = False

# ---------- GPS ----------
_prev_fix = None  # (lat, lon)

def _get_gps(timeout_s=6):
    """
    Liest eine gültige GPS-Position via gpspipe.
    Gibt (lat, lon, track_deg|None) zurück.
    """
    p = subprocess.Popen(["gpspipe", "-w", "-n", "50"],
                         stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    start = time.time()
    track = None
    lat = lon = None
    try:
        for raw in p.stdout:
            if time.time() - start > timeout_s:
                break
            try:
                o = json.loads(raw.decode("utf-8", "ignore"))
            except Exception:
                continue
            if o.get("class") == "TPV":
                if o.get("mode") in (2, 3):
                    if o.get("lat") is not None and o.get("lon") is not None:
                        lat, lon = float(o["lat"]), float(o["lon"])
                # 'track' (Grad) ist Vorzugsquelle für Kurs
                if o.get("track") is not None:
                    try:
                        track = float(o["track"])
                    except Exception:
                        pass
            if lat is not None and lon is not None:
                # wir haben Position; versuchen noch Track mitzunehmen
                if track is not None or time.time() - start > 1.0:
                    return lat, lon, track
    finally:
        try: p.terminate()
        except Exception: pass
    return None

def _bearing_deg(lat1, lon1, lat2, lon2):
    """Geografische Peilung (deg 0..360) von Punkt1 → Punkt2."""
    rlat1 = math.radians(lat1); rlat2 = math.radians(lat2)
    dlon  = math.radians(lon2 - lon1)
    y = math.sin(dlon) * math.cos(rlat2)
    x = math.cos(rlat1)*math.sin(rlat2) - math.sin(rlat1)*math.cos(rlat2)*math.cos(dlon)
    brng = (math.degrees(math.atan2(y, x)) + 360.0) % 360.0
    return brng

def _heading_word(deg):
    """Grad → Himmelsrichtung (de) in 8 Sektoren."""
    if deg is None:
        return ""
    dirs = ["Norden","Nordosten","Osten","Suedosten","Sueden","Suedwesten","Westen","Nordwesten"]
    idx = int((deg + 22.5) // 45) % 8
    return dirs[idx]

# ---------- Valhalla ----------
LEFT_TYPES     = {14, 15, 13}
RIGHT_TYPES    = {9, 8, 10}
UTURN_TYPES    = {12}
STRAIGHT_TYPES = {7, 20}                 # continue, stay_straight
MERGE_TYPES    = {23, 16, 17, 21, 22}    # merge / ramp / stay left/right
RA_ENTER       = 24
RA_EXIT        = 25
DEPART         = 1

def _mk_icon_code(m):
    t = m.get("type")
    if t in STRAIGHT_TYPES:
        return "STRAIGHT"
    if t in LEFT_TYPES or t in UTURN_TYPES:
        return "LEFT"
    if t in RIGHT_TYPES:
        return "RIGHT"
    if t in MERGE_TYPES:
        # Versuchen aus Text links/rechts
        txt = (m.get("verbal_pre_transition_instruction") or m.get("instruction") or "").lower()
        if "rechts" in txt: return "MERGE_R"
        if "links"  in txt: return "MERGE_L"
        return "STRAIGHT"
    if t == RA_EXIT:
        n = int(m.get("roundabout_exit_count", 0)) or 0
        return f"RA{n}" if 1 <= n <= 9 else "RA1"
    if t == RA_ENTER:
        return "RA1"
    return "STRAIGHT"

def _nice_distance_km_to_de(dist_km):
    if dist_km is None:
        return ""
    try:
        d = float(dist_km)
    except Exception:
        return ""
    if d < 0.995:
        return f"{int(round(d*1000))} m"
    return f"{d:.1f} km".replace(".", ",")

def _first_relevant_maneuver(mans):
    """Erstes 'relevantes' Manöver (DEPART überspringen)."""
    if not mans:
        return None
    if mans[0].get("type") == DEPART and len(mans) > 1:
        return mans[1]
    return mans[0]

def _valhalla_compact(cur_lat, cur_lon, heading_deg_for_straight):
    """
    Baut eine kompakte, strukturierte Ausgabe:
    CODE|DIST|STREET|HEADING
    - Bei Abbiegen/Merge/Roundabout: DIST gesetzt, HEADING leer
    - Bei Geradeaus (continue/stay): DIST leer, HEADING gesetzt
    - STREET immer gesetzt (soweit vorhanden)
    """
    payload = {
        "locations": [{"lat": cur_lat, "lon": cur_lon},
                      {"lat": DST_LAT, "lon": DST_LON}],
        "costing": "auto",
        "directions_options": {"language": "de-DE", "units": "kilometers"}
    }
    if EXCLUDE_TOLLS:
        payload["costing_options"] = {"auto": {"exclude_tolls": True}}

    res = subprocess.run(
        ["curl", "-s", "-H", "Content-Type: application/json",
         "-X", "POST", VALHALLA_URL, "-d", json.dumps(payload)],
        capture_output=True, text=True, timeout=10
    )
    data = json.loads(res.stdout)
    mans = data["trip"]["legs"][0]["maneuvers"]
    m = _first_relevant_maneuver(mans)
    if not m:
        return None

    t = m.get("type")
    code = _mk_icon_code(m)

    # Straße
    streets = m.get("street_names") or m.get("begin_street_names") or []
    street  = streets[0] if streets else ""

    # Felder säubern
    for repl in ("|", "\n", "\r"):
        street = street.replace(repl, " ")

    # Distanz / Heading
    if t in STRAIGHT_TYPES:
        dist = ""
        heading = _heading_word(heading_deg_for_straight)
    else:
        dist = _nice_distance_km_to_de(m.get("length"))
        heading = ""

    return f"{code}|{dist}|{street}|{heading}"

# ---------- Seriell ----------
def _open_serial_blocking(dev, baud):
    while True:
        try:
            ser = serial.Serial(dev, baud, timeout=2)
            try: ser.setDTR(False)
            except Exception: pass
            time.sleep(2)
            return ser
        except Exception:
            time.sleep(1)

# ---------- Hauptloop ----------
def _nav_loop():
    global _running, _stop, _prev_fix
    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
    last_sent = None
    try:
        while not _stop:
            fix = _get_gps(timeout_s=6)
            if not fix:
                time.sleep(INTERVAL)
                continue
            lat, lon, track = fix

            # Heading bestimmen: gps 'track' bevorzugt, sonst aus Vorgängerpunkt berechnen
            heading_deg = None
            if track is not None:
                heading_deg = (track % 360.0)
            elif _prev_fix is not None:
                heading_deg = _bearing_deg(_prev_fix[0], _prev_fix[1], lat, lon)
            _prev_fix = (lat, lon)

            try:
                line = _valhalla_compact(lat, lon, heading_deg)
            except Exception:
                line = None

            if line and line != last_sent:
                try:
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()
                    last_sent = line
                except Exception:
                    try: ser.close()
                    except Exception: pass
                    ser = _open_serial_blocking(SERIAL_DEV, BAUD)
                    ser.write((line + "\n").encode("utf-8"))
                    ser.flush()

            time.sleep(INTERVAL)
    finally:
        try: ser.close()
        except Exception: pass
        _running = False
        _stop = False

def main():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    print("Bereit. Button (GPIO 26) startet Navigation.")
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                # Start einmalig pro Tastendruck
                global _running
                if not _running:
                    _running = True
                    threading.Thread(target=_nav_loop, daemon=True).start()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        GPIO.cleanup()
Hinweise zum Verhalten
Pi → Arduino Format: CODE|DIST|STREET|HEADING

DIST nur bei Abbiege-/Merge-/Kreisverkehr-Manövern (z. B. 120 m).

HEADING nur bei „Geradeaus / dem Straßenverlauf folgen“ (z. B. Norden, Osten …).

STREET immer gesetzt (falls Valhalla einen Namen liefert).

Pi sendet nur bei Änderung → kein Flackern; Arduino zeichnet nur dann neu.

Himmelsrichtung wird aus GPS-track (oder notfalls aus zwei Punkten) berechnet.

Wenn du andere Richtungswörter bevorzugst (z. B. „Nordost“ statt „Nordosten“), sag kurz Bescheid – ich passe die Liste in _heading_word() an.

Du:
wenn dieses Programm funktioniert, muss ich dann immernoch nach dem Start des Pi den einten Knopf drücken um die Navigation zu starten?
ChatGPT:

Nachgedacht für 37s
Kurz: Ja. So wie der Pi-Code aktuell geschrieben ist, startet die Navigation erst nach einem Tastendruck (GPIO 26). Der main()-Loop wartet auf den Knopf und startet dann den Thread.

Wenn du ohne Knopfdruck direkt nach dem Start loslegen willst, ändere nur die main() so:

Variante A – Auto-Start (Knopf optional zum Neustarten):

def main():
    import time
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(BTN_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)

    print("Auto-Start: Navigation läuft.")
    # sofort starten
    global _running, _stop
    if not _running:
        _running = True
        threading.Thread(target=_nav_loop, daemon=True).start()

    # Optional: Knopf als „Neustart Navigation“
    while True:
        if GPIO.input(BTN_PIN) == GPIO.LOW:
            time.sleep(0.05)
            if GPIO.input(BTN_PIN) == GPIO.LOW:
                print("Button → Navigation neu starten.")
                _stop = True                # laufende Schleife anhalten
                while _running:
                    time.sleep(0.05)
                _stop = False
                _running = True
                threading.Thread(target=_nav_loop, daemon=True).start()
                while GPIO.input(BTN_PIN) == GPIO.LOW:
                    time.sleep(0.02)
        time.sleep(0.05)
Variante B – Auto-Start ganz ohne Knopf:

def main():
    import time
    GPIO.setmode(GPIO.BCM)
    print("Auto-Start: Navigation läuft (kein Button verwendet).")
    global _running
    _running = True
    threading.Thread(target=_nav_loop, daemon=True).start()
    while True:
        time.sleep(60)
Danach brauchst du den Button nicht mehr (A: nur zum Neustarten, B: gar nicht).





Keine ausgewähltKeine ausgewählt
ChatGPT kann Fehler machen. Überprüfe wichtige Informationen.
